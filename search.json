[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Practical Python Programming for Life Scientists",
    "section": "",
    "text": "Introduction\nWelcome to Practical Python Programming for Life Scientists! This book is designed for biology and life science students with little to no prior coding experience. Rather than aiming to make you Python experts, the goal is to help you develop fundamental programming concepts and data analysis skills using Python as a practical tool.\nThe content progresses from basic syntax through algorithms, functions, classes, error handling, data science applications, and testing methodologies. Each concept is presented with life science examples to show how programming principles can enhance your research capabilities.\nThis resource serves as an introduction to computational thinking in biological contexts, providing a solid foundation to approach scientific questions from a programming perspective and to effectively incorporate data analysis using Python into your research workflow.\nNote: This book is a work in progress and will continue to evolve with student feedback. Some sections may still be in development, with the main chapters expected to be finished by May 2025.\n\nPractical Python Programming for Life Scientists by Ryan M. Moore is licensed under CC BY 4.0",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "chapters/01_basics.html",
    "href": "chapters/01_basics.html",
    "title": "1  Basics",
    "section": "",
    "text": "Introduction to Python\nWelcome to your first Python tutorial! In this lesson, we’ll explore the fundamental building blocks of Python programming, including:\nThis is a comprehensive tutorial that covers a lot of ground. Don’t feel pressured to master everything at once – we’ll be practicing these concepts throughout the course. Think of this as your first exposure to these ideas, and we’ll build on them step by step in the coming weeks.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters/01_basics.html#introduction-to-python",
    "href": "chapters/01_basics.html#introduction-to-python",
    "title": "1  Basics",
    "section": "",
    "text": "What is Python?\nPython is a high-level, interpreted programming language known for its simplicity and readability. Created by Guido van Rossum in 1991, it has become one of the most popular languages in scientific computing and bioinformatics.\n\nHigh level\nPython is a high-level programming language, meaning it handles many complex computational details automatically. For example, rather than managing computer memory directly, Python does this for you. This allows biologists and researchers to focus on solving scientific problems rather than dealing with technical computing details.\n\n\nInterpreted\nPython is an interpreted language, which means you can write code and run it immediately without an extra compilation step. This makes it ideal for bioinformatics work where you often need to:\n\nTest different approaches to data analysis\nQuickly prototype analysis pipelines\nInteractively explore datasets\n\n\n\nReadable syntax\nPython’s code is designed to be readable and clear, often reading almost like English. For example:\nif dna_sequence.startswith(start_codon) and dna_sequence.endswith(stop_codon):\n    potential_genes.append(dna_sequence)\nEven if you’re new to programming, you can probably guess that this code is looking for potential genes by checking a DNA sequence for a start and a stop codon, and if found, adding the sequence to a list of potential genes.\nThis readability is particularly valuable in research settings where code needs to be shared and reviewed by collaborators.\n\n\n\nUse cases\nPython is a versatile language that can be used for a wide range of applications, including:\n\nArtificial intelligence and machine learning (e.g., TensorFlow, PyTorch)\nWeb development (Django, Flask)\nDesktop applications (PyQt, Tkinter)\nGame development (Pygame)\nAutomation and scripting\n\nAnd of course, bioinformatics and scientific computing:\n\nSequence analysis and processing (Biopython, pysam)\nPhylogenetics (ETE Toolkit)\nData visualization (matplotlib, seaborn)\nPipeline automation (snakemake for reproducible workflows)\nMicrobial ecology and microbiome analysis (QIIME)\n\n\n\nWhy Python for bioinformatics?\nPython has become a widely used tool in bioinformatics for several key reasons:\n\nRich ecosystem: Extensive libraries specifically for biological data analysis\nActive scientific community: Regular updates and support for bioinformatics tools\nIntegration capabilities: Easily connects with other bioinformatics tools and databases\nData science support: Strong support for data manipulation and statistical analysis\nReproducibility: Excellent tools for creating reproducible research workflows\n\nWhether you’re analyzing sequencing data, building analysis pipelines, or developing new computational methods, Python provides the tools and community support needed for modern biological research.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters/01_basics.html#variables",
    "href": "chapters/01_basics.html#variables",
    "title": "1  Basics",
    "section": "Variables",
    "text": "Variables\nThink of variables as labeled containers for storing data in your program. Just as you might label test tubes in a lab to keep track of different samples, variables let you give meaningful names to your data – whether they’re numbers, text, true/false values, or more complex information.\nFor example, instead of working with raw values like this:\n\nif 47 &gt; 40:\n    print(\"Temperature too high!\")\n\nTemperature too high!\n\n\nYou can use descriptive variables to make your code clearer:\n\ntemperature = 42.3\ntemperature_threshold = 40.0\n\nif temperature &gt; temperature_threshold:\n    print(\"Temperature too high!\")\n\nTemperature too high!\n\n\nIn this section, we’ll cover:\n\nCreating and using variables\nUnderstanding basic data types (numbers, text, true/false values)\nFollowing Python’s naming conventions\nConverting between different data types\nBest practices for using variables in scientific code\n\nBy the end, you’ll be able to use variables effectively to write clear, maintainable research code.\n\nCreating variables\nIn Python, you create a variable by giving a name to a value using the = operator. Here’s a basic example:\n\nsequence_length = 1000\nspecies_name = \"Escherichia coli\"\n\nYou can then use these variables anywhere in your code by referring to their names. Variables can be combined to create new variables:\n\n# Combining text (string) variables\ngenus = \"Escherichia\"\nspecies = \"coli\"\nfull_name = genus + \" \" + species\nprint(full_name)  # Prints: Escherichia coli\n\n# Calculations with numeric variables\nreads_forward = 1000000\nreads_reverse = 950000\ntotal_reads = reads_forward + reads_reverse\nprint(total_reads)  # Prints: 1950000\n\nEscherichia coli\n1950000\n\n\nNotice how the + operator works differently depending on what type of data we’re using:\n\nWith text (strings), it joins them together\nWith numbers, it performs addition\n\nYou can also use variables in more complex calculations:\n\ngc_count = 2200\ntotal_bases = 5000\ngc_content = gc_count / total_bases\nprint(gc_content)  # Prints: 0.44\n\n0.44\n\n\nThe ability to give meaningful names to values makes your code easier to understand and modify. Instead of trying to remember what the number 5000 represents, you can use a clear variable name like total_bases.\n\n\nReassigning variables\nPython allows you to change what’s stored in a variable after you create it. Let’s see how this works:\n\nread_depth = 100\nprint(f\"Initial read depth: {read_depth}\")\n\nread_depth = 47\nprint(f\"Updated read depth: {read_depth}\")\n\nInitial read depth: 100\nUpdated read depth: 47\n\n\nThis flexibility extends even further – Python lets you change not just the value, but also the type of data a variable holds:\n\nquality_score = 30\nquality_score = \"High quality\"\nprint(quality_score)\n\nHigh quality\n\n\nWhile this flexibility can be useful, it can also lead to unexpected behavior if you’re not careful. Here’s an example that could cause problems in a sequence analysis pipeline:\n\n# Correctly calculates and prints the total number of sequences.\nsequences_per_sample = 1000\nsample_count = 5\ntotal_sequences = sequences_per_sample * sample_count\nprint(f\"total sequences: {total_sequences}\")\n\n# This one produces an unexpected result!\nsequences_per_sample = \"1000 sequences \"\nsample_count = 5\ntotal_sequences = sequences_per_sample * sample_count\nprint(f\"total sequences: {total_sequences}\")\n\ntotal sequences: 5000\ntotal sequences: 1000 sequences 1000 sequences 1000 sequences 1000 sequences 1000 sequences \n\n\nIn the second case, instead of performing multiplication, Python repeats the string \"1000 sequences \" 5 times! This is probably not what you wanted in your genomics pipeline!\nThis kind of type changing can be a common source of bugs, especially when:\n\nProcessing input from files or users\nHandling missing or invalid data\nConverting between different data formats\n\nBest practice is to be consistent with your variable types throughout your code, and explicitly convert between types when necessary.\n\nAugmented assignments\nLet’s look at a common pattern when working with variables. Here’s one way to increment a counter:\n\nread_count = 100\nread_count = read_count + 50\nprint(f\"Total reads: {read_count}\")\n\nTotal reads: 150\n\n\nPython provides a shorter way to write this using augmented assignment operators:\n\nread_count = 100\nread_count += 50\nprint(f\"Total reads: {read_count}\")\n\nTotal reads: 150\n\n\nThese augmented operators combine arithmetic with assignment. Common ones include:\n\n+=: augmented addition (increment)\n-=: augmented subtraction (decrement)\n*=: augmented multiplication\n/=: augmented division\n\nThese operators are particularly handy when updating running totals or counters, like when tracking how many sequences pass quality filters. We’ll explore more uses in the next tutorial.\n\n\n\nNamed constants\nSometimes you’ll want to define values that shouldn’t change throughout your program.\n\nGENETIC_CODE_SIZE = 64\nprint(f\"There are {GENETIC_CODE_SIZE} codons in the standard genetic code\")\n\nDNA_BASES = ['A', 'T', 'C', 'G']\nprint(f\"The DNA bases are: {DNA_BASES}\")\n\nThere are 64 codons in the standard genetic code\nThe DNA bases are: ['A', 'T', 'C', 'G']\n\n\nIn Python, we use ALL_CAPS names as a convention to indicate these values shouldn’t change. However, it’s important to understand that Python doesn’t actually prevent these values from being changed. For example:\n\nMIN_QUALITY_SCORE = 30\nprint(f\"Filtering sequences with quality scores below {MIN_QUALITY_SCORE}\")\n\nMIN_QUALITY_SCORE = 20  # We can change it, even though we shouldn't!\nprint(f\"Filtering sequences with quality scores below {MIN_QUALITY_SCORE}\")\n\nFiltering sequences with quality scores below 30\nFiltering sequences with quality scores below 20\n\n\nThink of Python variables like labels on laboratory samples: you can always move a label from one test tube to another. When you write:\n\nDNA_BASES = ['A', 'T', 'C', 'G']\nDNA_BASES = ['A', 'U', 'C', 'G']  # Oops, switched to RNA bases!\nprint(f\"These are now RNA bases: {DNA_BASES}\")\n\nThese are now RNA bases: ['A', 'U', 'C', 'G']\n\n\nYou’re not modifying the original list of DNA bases – instead, you’re creating a new list and moving the DNA_BASES label to point to it. The original list isn’t “protected” in any way. So, it’s more of a convention that ALL_CAPS variables be treated as constants in your code, even though Python won’t enforce this rule.\n\n\nDangerous assignments\nHere’s a common pitfall when naming variables in Python – accidentally overwriting built-in functions.\nPython has several built-in functions that are always available, including one called str that converts values to strings. For example:\nsequence = str()  # Creates an empty string\nsequence\nNote: if you convert this static code block to one that is runnable, and then actually run it, it would cause errors in the rest of the notebook in any place that uses the str function. If you do this, you will need to restart the notebook kernel.\nHowever, Python will let you use these built-in names as variable names (though you shouldn’t!):\nstr = \"ATCGGCTAA\"  # Don't do this!\nNow if you try to use the str function later in your code:\nquality_score = 35\nsequence_info = str(quality_score)  # This will fail!\nYou’ll get an error:\nTypeError: 'str' object is not callable\nThis error occurs because we’ve “shadowed” the built-in str function with our own variable. Python now thinks we’re trying to use the string “ATCGGCTAA” as a function, which doesn’t work!\nWe’ll discuss errors in more detail in a future lesson. For now, remember to avoid using Python’s built-in names (like str, list, dict, set, len) as variable names. You can find a complete list of built-ins in the Python documentation.\n\n\nNaming variables\nClear, descriptive variable names are crucial for writing maintainable code. When you revisit your analysis scripts months later, good variable names will help you remember what each part of your code does.\n\nValid names\nPython variable names can include:\n\nLetters (A-Z, a-z)\nNumbers (0-9, but not as the first character)\nUnderscores (_)\n\nWhile Python allows Unicode characters (like Greek letters), it’s usually better to stick with standard characters:\n\nπ = 3.14  # Possible, but not recommended\npi = 3.14  # Better!\n\n\n\nCase Sensitivity\nPython treats uppercase and lowercase letters as different characters:\n\nsequence = \"ATCG\"\nSequence = \"GCTA\"\nprint(f\"{sequence} != {Sequence}\")\n\nATCG != GCTA\n\n\nTo avoid confusion, stick with lowercase for most variable names.\n\n\nNaming Conventions\nFor multi-word variable names, Python programmers typically use snake_case (lowercase words separated by underscores):\n\n# Good -- snake case\nread_length = 150\nsequence_count = 1000\nis_high_quality = True\n\n# Avoid - camelCase or PascalCase\nreadLength = 150\nSequenceCount = 1000\n\n\n\nGuidelines for Good Names\nHere are some best practices for naming variables in your code:\nUse descriptive names that explain the variable’s purpose:\n\n# Clear and descriptive\nsequence_length = 1000\nquality_threshold = 30\n\n# Too vague\nx = 1000\nthreshold = 30\n\nUse nouns for variables that hold values:\n\nread_count = 500\ndna_sequence = \"ATCG\"\n\nBoolean variables often start with is_, has_, or similar:\n\nis_paired_end = True\nhas_adapter = False\n\nCollections (which we’ll cover later) often use plural names:\n\nsequences = [\"ATCG\", \"GCTA\"]\nquality_scores = [30, 35, 40]\n\nCommon exceptions where short names are okay:\n\ni, j, k for loop indices\nx, y, z for coordinates\nStandard abbreviations like msg for message, num for number\n\nKeep names reasonably short while still being clear:\n\n# Too long\nnumber_of_sequences_passing_quality_filter = 100\n# Better\npassing_sequences = 100\n\nRemember: your code will be read more often than it’s written, both by others and by your future self. Clear variable names make your code easier to understand and maintain.\nFor more detailed naming guidelines, check Python’s PEP 8 Style Guide.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters/01_basics.html#data-types",
    "href": "chapters/01_basics.html#data-types",
    "title": "1  Basics",
    "section": "Data Types",
    "text": "Data Types\nPython has many different types of data it can work with. Each data type has its own special properties and uses.\nIn this section, we’ll cover the basic data types you’ll use frequently in your code:\n\nNumbers\n\nIntegers (whole numbers, like sequence lengths or read counts)\nFloating-point numbers (decimal numbers, like expression levels or ratios)\n\nStrings (text, like DNA sequences or gene names)\nBoolean values (True/False, like whether a sequence passed quality control)\n\nWe’ll learn how to:\n\nIdentify what type of data you’re working with\nConvert between different types when needed\n\nUnderstanding these fundamental data types is crucial for handling data correctly in your programs.\n\nChecking the type of a value\nPython is a dynamically typed language, meaning a variable’s type can change during your program. While this flexibility is useful, it’s important to keep track of your data types to avoid errors in your analysis.\nYou can check a variable’s type using Python’s built-in type() function. Here’s how:\n\nsequence_length = 150\nprint(type(sequence_length))  # &lt;class 'int'&gt;\n\nsequence = \"ATCGGCTAA\"\nprint(type(sequence))  # &lt;class 'str'&gt;\n\nis_valid = True\nprint(type(is_valid))  # &lt;class 'bool'&gt;\n\n&lt;class 'int'&gt;\n&lt;class 'str'&gt;\n&lt;class 'bool'&gt;\n\n\nAs shown above, type() tells us exactly what kind of data we’re working with. This can be particularly helpful when debugging calculations that aren’t working as expected, or verifying data is in the correct format.\nDon’t worry too much about the class keyword in the output – we’ll cover classes in detail later. For now, focus on recognizing the basic types: int for integers, str for strings (text), and bool for True/False values.\n\n\nNumeric types (int, float)\nPython has two main types for handling numbers:\n\nint: Integers (whole numbers) for counting things like:\n\nNumber of sequences\nRead lengths\nGene counts\n\nfloat: Floating-point numbers (decimals) for measurements like:\n\nExpression levels\nP-values\nGC content percentages\n\n\nFor readability with large numbers, you can use underscores: 1_000_000 reads is clearer than 1000000 reads.\n\nNumeric operations\nThe operators +, -, *, / are used to perform the basic arithmetic operations.\n\nforward_reads = 1000\nreverse_reads = 800\nprint(forward_reads + reverse_reads)\nprint(forward_reads - reverse_reads)\nprint(forward_reads * 2)\nprint((forward_reads + reverse_reads) / 100)\n\n1800\n200\n2000\n18.0\n\n\nFloat division (/) always returns a float, whereas integer division (//) returns an int by performing floor division.\n\ntotal_bases = 17\nreads = 5\nprint(total_bases / reads)\nprint(total_bases // reads)\n\n3.4\n3\n\n\nThe operator ** is used for exponentiation.\n\nprint(2 ** 8)\nprint(8 ** 2)\n\n256\n64\n\n\nParentheses () can be used to group expressions and control the order of operations.\n\n# Order of operations\nprint(2 + 3 * 4)     # multiplication before addition\nprint( (2 + 3) * 4 ) # parentheses first\n\n14\n20\n\n\nModulo (%) gives remainder of division\n\nposition = 17\ncodon_position = position % 3  # Which position in codon (0, 1, or 2)\nprint(codon_position)\n\n2\n\n\nBe careful about combining negative numbers with floor division or modulo. Here are some interesting examples showing how negative numbers behave with floor division and modulo in Python:\n\n# Floor division with negative numbers\nprint(\"Floor division with negative numbers:\")\n# Rounds down to nearest integer\nprint(17 // 5)\n# Rounds down, not toward zero\nprint(-17 // 5)\nprint(17 // -5)\nprint(-17 // -5)\n\n# Modulo with negative numbers\nprint(\"\\nModulo with negative numbers:\")\nprint(17 % 5)\n# Result is positive with positive divisor\nprint(-17 % 5)\n# Result has same sign as divisor\nprint(17 % -5)\nprint(-17 % -5)\n\nFloor division with negative numbers:\n3\n-4\n-4\n3\n\nModulo with negative numbers:\n2\n3\n-3\n-2\n\n\nDon’t worry too much about the details of how negative numbers work with division and modulo operations. Just be aware that they can behave unexpectedly, and look up the specific rules if you need them.\n\n\nScientific notation\nScientific notation is essential when working with very large or small numbers:\n\n# 3.2 billion bases\ngenome_size = 3.2e9\n\n# 0.00000001 mutations per base\nmutation_rate = 1e-8\n\n\n\nPrecision Considerations\n\nIntegers\nPython can handle arbitrarily large integers, limited only by memory:\n\nbig_number = 125670495610435017239401723907559279347192756\nprint(big_number)\n\n125670495610435017239401723907559279347192756\n\n\n\n\nFloats\nFloating-point numbers have limited precision (about 15-17 decimal digits). This can affect calculations:\n\nx = 0.1\ny = 0.2\n\n# Might not be exactly 0.3\nprint(x + y)\n\n0.30000000000000004\n\n\nWhile these precision errors are usually small, they can accumulate in large-scale calculations.\n\n\n\n\nStrings\nStrings are how Python handles text data, like sequences or gene names.\n\n# Strings can use single or double quotes\nsequence = 'ATCG'\ngene_name = \"nrdA\"\nprint(sequence)\nprint(gene_name)\n\nATCG\nnrdA\n\n\nStrings are immutable – once created, they cannot be modified. For example, you can’t change individual bases in a sequence directly:\n\ndna = \"ATCG\"\n# This would raise an error:\n# dna[0] = \"G\"\n\nTry uncommenting that line and see what happens!\nYou can combine strings using the + operator:\n\n# String concatenation\nsequence_1 = \"ATCG\"\nsequence_2 = \"GCTA\"\nfull_sequence = sequence_1 + sequence_2\nprint(\"the sequence is: \" + full_sequence)\n\nthe sequence is: ATCGGCTA\n\n\nSpecial characters can be included using escape sequences:\n\n\\n for new line\n\\t for tab\n\\\\ for backslash\n\n\n# Formatting sequence output\nprint(\"Sequence 1:\\tATCG\\nSequence 2:\\tGCTA\")\n\nSequence 1: ATCG\nSequence 2: GCTA\n\n\nF-strings (format strings) are particularly useful for creating formatted output. They allow you to embed variables and expressions in strings using {expression}:\n\ngene_id = \"nrdJ\"\nposition = 37_531\n\nprint(f\"Gene {gene_id} is located at position {position}\")\n\nGene nrdJ is located at position 37531\n\n\nF-strings can also format numbers, which is useful for scientific notation and precision control:\n\n# Two decimal places\ngc_content = 0.42857142857\nprint(f\"GC content: {gc_content:.2f}\")\n\n# Scientific notation\np_value = 0.000000342\nprint(f\"P-value: {p_value:.2e}\")\n\nGC content: 0.43\nP-value: 3.42e-07\n\n\nStrings can contain Unicode characters:\n\n# Unicode characters\nprint(\"你好\")\nprint(\"こんにちは\")\n\n你好\nこんにちは\n\n\nWhile Python supports Unicode characters in variable names, it’s better to use standard ASCII characters for code:\n\n# Possible, but not recommended\nα = 0.05\nβ = 0.20\n\n# Better\nalpha = 0.05\nbeta = 0.20\n\n\nCommon string operations\nString operations are fundamental for processing and manipulating textual data, formatting output, and cleaning up input in your applications and analysis pipelines.\n\nString concatenation with +\nThe + operator joins strings together:\n\n# Joining DNA sequences\nsequence1 = \"ATCG\"\nsequence2 = \"GCTA\"\ncombined_sequence = sequence1 + sequence2\nprint(combined_sequence)\n\n# Adding labels to sequences\ngene_id = \"nrdA\"\nlabeled_sequence = gene_id + \": \" + combined_sequence\nprint(labeled_sequence)\n\nATCGGCTA\nnrdA: ATCGGCTA\n\n\n\n\nString repetition with *\nThe * operator repeats a string a specified number of times:\n\n# Repeating DNA motifs\nmotif = \"AT\"\nrepeat = motif * 3\nprint(repeat)\n\n# Creating alignment gap markers\ngap = \"-\" * 6\nprint(gap)\n\nATATAT\n------\n\n\n\n\nString indexing\nPython uses zero-based indexing to access individual characters in a string. You can also use negative indices to count from the end:\n\n# Indexing\ns = \"Hello, world!\"\nprint(s[0])\nprint(s[7])\nprint(s[-1])\nprint(s[-8])\n\nH\nw\n!\n,\n\n\n\n\nString slicing\nSlicing lets you extract parts of a string using the format [start:end]. The end index is exclusive:\n\n# Slicing\ns = \"Hello, World!\"\nprint(s[0:5])\nprint(s[7:])\nprint(s[:5])\nprint(s[-6:])\nprint(s[-12:-8])\n\nHello\nWorld!\nHello\nWorld!\nello\n\n\n\n\nString methods\nPython strings have built-in methods for common operations. Here are a few common ones:\n\n# Clean up sequence data with leading/trailing white space\nraw_sequence = \"  ATCG GCTA  \"\nclean_sequence = raw_sequence.strip()\nprint(\"|\" + raw_sequence + \"|\")\nprint(\"|\" + clean_sequence + \"|\")\n\n# Convert between upper and lower case\nmixed_sequence = \"AtCg\"\nprint(mixed_sequence.upper())\nprint(mixed_sequence.lower())\n\n# Chaining methods\nmessy_sequence = \"  AtCg  \"\nclean_upper = messy_sequence.strip().upper()\nprint(\"|\" + clean_upper + \"|\")\n\n|  ATCG GCTA  |\n|ATCG GCTA|\nATCG\natcg\n|ATCG|\n\n\n\n\n\n\nBoolean values\nBoolean values represent binary states (True/False) and are used to make decisions in code:\n\nTrue represents a condition being met\nFalse represents a condition not being met\n\n(Note: These are capitalized keywords in Python!)\nBoolean variables often use prefixes like is_, has_, or contains_ to clearly indicate their purpose:\nis_paired_end = True\nhas_adapter = False\ncontains_start_codon = True\nBoolean values are used in control flow – they drive decision-making in your code:\n\nis_high_quality = True\nif is_high_quality:\n    print(\"Sequence passes quality check!\")\n\nhas_ambiguous_bases = False\nif has_ambiguous_bases:\n    # This won't execute because condition is False\n    print(\"Warning: Sequence contains N's\")\n\nSequence passes quality check!\n\n\nBoolean values are created through comparisons, for example:\n\n# Quality score checking\nquality_score = 35\nprint(quality_score &gt; 30)\nprint(quality_score &lt; 20)\nprint(quality_score == 40)\nprint(quality_score != 35)\n\nTrue\nFalse\nFalse\nFalse\n\n\nLogical operators (and, or, not) combine boolean values:\n\n# Logical operations\nprint(True and False)\nprint(True or False)\nprint(not True)\nprint(not False)\n\nFalse\nTrue\nFalse\nTrue\n\n\nFor example, you could use logical operators to combine multiple logical statements:\nis_long_enough and is_high_quality\n\nis_exempt or exceeds_threshold\n\nComparison operators In Depth\nComparison operators are used to compare “compare” values. They return a boolean value (True or False) and are often used in conditional statements and loops to control program flow.\nThe basic comparison operators are:\n\n==: equal to\n!=: not equal to\n&lt;: strictly less than\n&lt;=: less than or equal to\n&gt;: strictly greater than\n&gt;=: greater than or equal to\n\nAdditional operators we’ll cover later:\n\nis, is not: object identity\nin, not in: sequence membership\n\nHere are a couple examples:\n\n# Basic boolean values\nis_sunny = True\nis_raining = False\n\nprint(f\"Is it sunny? {is_sunny}\")\nprint(f\"Is it raining? {is_raining}\")\n\n# Comparison operations produce boolean results\ntemperature = 25\nis_hot = temperature &gt; 30\nprint(f\"Is it hot? {is_hot}\")\n\n# Logical operations\nis_good_weather = is_sunny and not is_raining\nprint(f\"Is it good weather? {is_good_weather}\")\n\nIs it sunny? True\nIs it raining? False\nIs it hot? False\nIs it good weather? True\n\n\n\n# Comparison operations\nprint(5 == 5)\nprint(5 != 5)\nprint(5 &lt; 3)\nprint(5 &lt;= 3)\nprint(5 &lt;= 5)\nprint(5 &gt; 3)\nprint(5 &gt;= 3)\nprint(5 &gt;= 5)\n\nTrue\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\nTrue\n\n\n\nChained Comparisons\nComparisons can be chained together, e.g. 1 &lt; 2 &lt; 3 is equivalent to 1 &lt; 2 and 2 &lt; 3.\n\n# Chained comparisons\nprint(1 &lt; 2 &lt; 3)\nprint(1 &lt; 2 &lt; 2)\nprint(1 &lt; 2 &lt;= 2)\n\n# This one is a bit weird, but it's valid Python!\nprint(1 &lt; 2 &gt; 2)\n\nTrue\nFalse\nTrue\nFalse\n\n\nThe comparisons operators can also be used to compare the values of variables.\n\n# Check if value is in valid range\ncoverage = 30\nprint(10 &lt; coverage &lt; 50)\n\nquality_score = 35\nprint(20 &lt; quality_score &lt;= 40)\n\n# Multiple range checks\ntemperature = 37.2\nprint(37.0 &lt;= temperature &lt;= 37.5)\n\nTrue\nTrue\nTrue\n\n\n\n\nComparing Strings & Other Values\nPython’s comparison operators work beyond just numbers, allowing comparisons between various types of data. Be careful though – while some comparisons make intuitive sense, others might require careful consideration or custom implementation.\n\n# Comparison of different types\nprint(\"Hello\" == \"Hello\")\nprint(\"Hello\" == \"World\")\nprint(\"Hello\" == 5)\nprint(\"Hello\" == True)\n\n# Some non-numeric types also have a natural ordering.\nprint(\"a\" &lt; \"b\")\nprint(\"a\" &lt; \"A\")\n\n# This is a bit weird, but it's valid Python!\nprint([1, 2, 3] &lt;= [10, 20, 30])\n\nTrue\nFalse\nFalse\nFalse\nTrue\nFalse\nTrue\n\n\n\n\n\nLogical Operators In Depth\nThink of logical operators as ways to combine or modify simple yes/no conditions in your code, much like how you might combine criteria when filtering data in Excel or selecting samples for an experiment.\nFor example, you can use logical operators to express conditions like:\n\n“If a DNA sequence is both longer than 250 bases AND has no ambiguous bases, include it in the analysis”\n“If a gene is either highly expressed OR shows significant differential expression, flag it for further study”\n“If a sample is NOT properly labeled, skip it and log a warning”\n\nThese operators (and, or, not) work similarly to the way we combine conditions in everyday language. Just as you might say “I’ll go for a run if it’s not raining AND the temperature is above 60°F,” you can write code that makes decisions based on multiple criteria.\nHere are a couple of examples:\n# In a sequence quality filtering pipeline\n#\n# Both conditions must be true\nif sequence_length &gt;= 250 and quality_score &gt;= 30:\n    keep(sequence)\n\n# In a variant calling pipeline\n#\n# Either condition being true is sufficient\nif mutation_frequency &gt; 0.01 or supporting_reads &gt;= 100:\n    report(variant)\n\n# In a data validation step\n#\n# Triggers if the condition is false\nif not sample_id.startswith('PROJ_'):\n    warn_user(sample_id)\nThink of these operators as the digital equivalent of the decision-making process you use in the lab: checking multiple criteria before proceeding with an experiment, or having alternative procedures based on different conditions.\n\nBehavior of logical operators\nLet’s explore how Python’s logical operators (and, or, not) work, using examples relevant to biological data analysis.\nThink of these operators as ways to check multiple conditions, similar to how you might design experimental criteria:\n\nand: Like requiring ALL criteria to be met (e.g., both proper staining AND correct cell count)\nor: Like accepting ANY of several criteria (e.g., either elevated temperature OR positive test result)\nnot: Like reversing a condition (e.g., NOT contaminated)\n\nHere’s a truth table showing all possible combinations.\n\n\n\nA\nB\nA and B\nA or B\nnot A\n\n\n\n\nTrue\nTrue\nTrue\nTrue\nFalse\n\n\nTrue\nFalse\nFalse\nTrue\nFalse\n\n\nFalse\nTrue\nFalse\nTrue\nTrue\n\n\nFalse\nFalse\nFalse\nFalse\nTrue\n\n\n\nHere are the rules:\n\nand only gives True if both conditions are True (like requiring all quality checks to pass)\nor gives True if at least one condition is True (like having multiple acceptable criteria)\nnot flips True to False and vice versa (like converting “passed QC” to “failed QC”)\n\nInterestingly, Python can also evaluate non-boolean values (values that aren’t strictly True or False) using these operators. We call values that Python treats as True “truthy” and values it treats as False “falsy”. This becomes important when working with different types of data in your programs and analysis pipelines.\n\n\nUnderstanding “Truthy” and “Falsy” Values\nIn Python, every value can be interpreted as either “true-like” (truthy) or “false-like” (falsy) when used in logical operations. This is similar to how in biology, we might categorize results as “positive” or “negative” even when the underlying data is more complex than a simple yes/no.\nThink of “falsy” values as representing empty, zero, or null states – essentially, the absence of meaningful data. Python considers the following values as “falsy”:\n\nFalse: The boolean False value\nNone: Python’s way of representing “nothing” or “no value” (like a blank entry in a spreadsheet)\nAny form of zero (like 0, 0.0)\nEmpty containers:\n\nEmpty string (\"\")\nEmpty list ([])\nEmpty set (set())\nEmpty dictionary ({})\n\n\nEverything else is considered “truthy” - meaning it represents the presence of some meaningful value or data.\nLet’s look at some practical examples. We can use Python’s bool() function to explicitly check whether Python considers a value truthy or falsy:\n\n# Examples from sample processing:\nsample_count = 0\n# False (no samples)\nprint(bool(sample_count))\n\nsample_ids = []\n# False (empty list of IDs)\nprint(bool(sample_ids))\n\npatient_data = {}\n # False (empty data table)\nprint(bool(patient_data))\n\n# Compare with:\nsample_count = 5\n# True (we have samples)\nprint(bool(sample_count))\n\nsample_ids = [\"A1\", \"B2\"]\n# True (we have some IDs)\nprint(bool(sample_ids))\n\npatient_data = {\"age\": 45}\n# True (we have some data)\nprint(bool(patient_data))\n\nFalse\nFalse\nFalse\nTrue\nTrue\nTrue\n\n\nUnderstanding truthy and falsy values becomes particularly useful when writing conditions in your code, like checking whether you have data before proceeding with analysis:\n# Sort of like saying: if there are some samples IDs,\n# then do something with them.\nif sample_ids:\n    process_samples(sample_ids)\nelse:\n    print(\"No samples to process\")\nWe’ll see more examples of how this concept is useful in practice as we work through more advanced topics.\n\n\nEven More Details About and and or\nNote: This section is a bit low-level, so don’t worry too much about it. It’s just here for your reference.\nOne kind of neat thing about the logical operators is that you can directly use them as a type of control flow.\n\nand\nGiven an expression a and b, the following steps are taken:\n\nFirst, evaluate a.\nIf a is “falsy”, then return the value of a.\nOtherwise, evaluate b and return its value.\n\nCheck it out:\n\na = \"apple\"\nb = \"banana\"\nresult = a and b\nprint(result)\n\nname = \"Maya\"\nage = 45\nresult = age &gt;= 18 and f\"{name} is an adult\"\nprint(result)\n\nname = \"Amira\"\nage = 15\nresult = age &gt;= 18 and f\"{name} is an adult\"\nprint(result)\n\nbanana\nMaya is an adult\nFalse\n\n\nWere the values assigned to result what you expected?\n\n\nor\nGiven an expression a or b, the following steps are taken:\n\nFirst, evaluate a.\nIf a is “truthy”, then return the value of a.\nOtherwise, evaluate b and return its value.\n\nLet’s return to the previous example, but this time we will use or instead of and.\n\na = \"apple\"\nb = \"banana\"\nresult = a or b\nprint(result)\n\nname = \"Maya\"\nage = 45\n# Observe that this code isn't really doing what we want it to do.\n# `result` will be True, rather than \"Maya is an adult\".\n# That's because it should be using `and`\n#   ...again, it's just for illustration.\nresult = age &gt;= 18 or f\"{name} is an adult\"\nprint(result)\n\nname = \"Amira\"\nage = 15\n# This code is a bit obscure, and you probably wouldn't\n# write it like this in practice.  But it illustrates the\n# point.\nresult = age &gt;= 18 or f\"{name} is not an adult\"\nprint(result)\n\napple\nTrue\nAmira is not an adult\n\n\nWere the values assigned to result what you expected?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters/01_basics.html#control-flow",
    "href": "chapters/01_basics.html#control-flow",
    "title": "1  Basics",
    "section": "Control Flow",
    "text": "Control Flow\nThink of control flow as the decision-making logic in your code - like following a lab protocol, but for data analysis. Just as you make decisions in the lab (“if the pH is too high, add buffer”), your code needs to make decisions about how to handle different situations.\nControl flow statements are the programming equivalent of those decision points in your protocols. They let your program take different paths depending on the conditions it encounters, much like how you might follow different steps in an experiment based on your observations.\nIn this section, we’ll cover several ways to build these decision points into your code:\n\nSimple if statements (like “if the sequence quality is low, skip it”)\nif-else statements (like “if the gene is expressed, mark it as active; otherwise, mark it as inactive”)\nif-elif-else chains (for handling multiple possibilities, like different ranges of p-values)\nNested conditions (for more complex decisions, like filtering sequences based on multiple quality metrics)\n\nControl flow is essential for writing programs that can:\n\nMake decisions based on data\nHandle different scenarios\nRespond to user input\nConditionally process data\n\nJust as following the right branch points in a protocol is crucial for experimental success, proper control flow is key to writing programs that correctly handle your data.\nLet’s explore the main types of control flow in Python:\n\nif Statements\nThink of these as your basic yes/no checkpoints, like checking if a sample meets quality control:\n\nquality_score = 35\nif quality_score &gt; 30:\n    print(\"Sample passes QC\")\n\nSample passes QC\n\n\n\n\nif-else Statements\nThese handle two alternative outcomes, like categorizing genes as expressed or not expressed:\n\nexpression_level = 1.5\nif expression_level &gt; 1.0:\n    print(\"Gene is upregulated\")\nelse:\n    print(\"Gene is not upregulated\")\n\nGene is upregulated\n\n\n\n\nif-elif-else Chains\nPerfect for handling multiple possibilities, like categorizing p-values or expression levels:\n\np_value = 0.03\nif p_value &lt; 0.01:\n    print(\"Highly significant\")\nelif p_value &lt; 0.05:\n    print(\"Significant\")\nelse:\n    print(\"Not significant\")\n\nSignificant\n\n\n\n\nMultiple Conditions\nSometimes you need to check multiple criteria, like filtering sequencing data:\n\nread_length = 100\ngc_content = 0.45\nquality_score = 35\n\nif read_length &gt;= 100 and quality_score &gt; 30 and 0.4 &lt;= gc_content &lt;= 0.6:\n    print(\"Read passes all quality filters\")\nelse:\n    print(\"Read filtered out\")\n\nRead passes all quality filters\n\n\n\n\nKey Points to Remember\n\nConditions are checked in order from top to bottom\nOnly the first matching condition’s code block will execute\nKeep your conditions clear and logical, like a well-designed experimental workflow\nTry to avoid deeply nested conditions as they can become confusing\n\nThink of control flow as building decision points into your data analysis pipeline. Just as you wouldn’t proceed with a PCR if your DNA quality was poor, your code can automatically make similar decisions about data processing.\n\n\nNested Conditional Statements\nConditional statements can also be nested. Here is some code that is checking if someone can go to the beach. If they are not at work, and the weather is sunny, then they can go to the beach.\n\nat_work = False\nweather = \"sunny\"\n\nif weather == \"sunny\" and not at_work:\n    print(\"It's sunny and you are not at work, let's go to the beach!\")\nelse:\n    print(\"We can't go to the beach today for some reason.\")\n\n# Let's move the check for at_work nested inside the if statement that checks\n# the weather.\n#\n# Note that this code isn't equivalent to the previous code, just an example\n# of nesting.\n\nif weather == \"sunny\":\n    if at_work:\n        print(\"You are at work and can't go to the beach.\")\n    else:\n        print(\"It's sunny and you are not at work, let's go to the beach!\")\nelse:\n    print(\"It's not sunny, so we can't go to the beach regardless.\")\n\n# Just to be clear, let's \"unnest\" that conditional.\nif weather == \"sunny\" and at_work:\n    print(\"You are at work and can't go to the beach.\")\nelif weather == \"sunny\":\n    print(\"It's sunny and you are not at work, let's go to the beach!\")\nelse:\n    print(\"It's not sunny, so we can't go to the beach regardless.\")\n\nIt's sunny and you are not at work, let's go to the beach!\nIt's sunny and you are not at work, let's go to the beach!\nIt's sunny and you are not at work, let's go to the beach!\n\n\n\n\nA Note on Keeping Things Simple\nJust as you want to keep your experimental protocols clear and straightforward, the same principle applies to writing conditional statements in your code. Think of deeply nested if-statements like trying to follow a complicated diagnostic flowchart - the more branches and decision points you add, the easier it is to lose track of where you are.\nFor example, imagine designing a PCR troubleshooting guide where each problem leads to three more questions, each with their own set of follow-up questions. While technically complete, it would be challenging for anyone to follow correctly. The same goes for code – when we stack too many decisions inside other decisions, we’re setting ourselves up for confusion.\nHere’s why keeping conditions simple matters:\n\nEach decision point is an opportunity for something to go wrong (like each step in a protocol)\nComplex nested conditions are harder to debug (like trying to figure out where a multi-step experiment went wrong)\nSimple, clear code is easier for colleagues to review and understand\n\nWhen you find yourself writing deeply nested conditions, it’s often a sign to step back and consider whether there’s a clearer way to structure your code.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters/01_basics.html#basic-built-in-functions",
    "href": "chapters/01_basics.html#basic-built-in-functions",
    "title": "1  Basics",
    "section": "Basic Built-in Functions",
    "text": "Basic Built-in Functions\nThink of Python’s built-in functions as your basic laboratory toolkit - they’re always there when you need them, no special setup required. These functions will become your go-to tools for handling biological data, from DNA sequences to experimental measurements.\nHere are some of the most useful built-in functions you’ll use regularly:\n\nprint(): Displays your data or results\nlen(): Counts the length of something\nabs(): Gives you the absolute value\nround(): Tidies up decimal numbers\nmin() and max(): Find the lowest and highest values\nsum(): Adds up a collection of numbers\ntype(): Tells you what kind of data you’re working with (helpful for debugging)\n\nLet’s look at some examples:\n\n# Printing experimental results\nprint(\"Gene expression analysis complete!\")\n\n# Checking sequence length\ndna_sequence = \"ATCGATCGTAGCTAGCTAG\"\nlength = len(dna_sequence)\nprint(f\"This DNA sequence is {length} base pairs long.\")\n\n# Working with expression fold changes\nfold_change = -2.5\nabsolute_change = abs(fold_change)\nprint(f\"The absolute fold change is {absolute_change}x.\")\n\n# Cleaning up p-values\np_value = 0.0000234567\nrounded_p = round(p_value, 6)\nprint(f\"p-value = {rounded_p}\")\n\n# Analyzing multiple expression values\nexpression_levels = [10.2, 5.7, 8.9, 12.3, 6.8]\nlowest = min(expression_levels)\nhighest = max(expression_levels)\nprint(f\"Expression range: {lowest} to {highest}\")\n\n# Calculating average coverage\ncoverage_values = [15, 22, 18, 20, 17]\naverage_coverage = sum(coverage_values) / len(coverage_values)\nprint(f\"Average sequencing coverage: {average_coverage}x\")\n\n# Checking data types\ngene_name = \"nrdA\"\ndata_type = type(gene_name)\nprint(f\"The variable gene_name is of type: {data_type}\")\n\nGene expression analysis complete!\nThis DNA sequence is 19 base pairs long.\nThe absolute fold change is 2.5x.\np-value = 2.3e-05\nExpression range: 5.7 to 12.3\nAverage sequencing coverage: 18.4x\nThe variable gene_name is of type: &lt;class 'str'&gt;\n\n\nTo use these functions, just type the function name followed by parentheses containing your data (the “arguments”). Some functions, like min() and max(), can handle multiple inputs, which is handy when comparing several values at once.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters/01_basics.html#wrap-up",
    "href": "chapters/01_basics.html#wrap-up",
    "title": "1  Basics",
    "section": "Wrap-Up",
    "text": "Wrap-Up\nIn this tutorial, we covered the fundamental building blocks of Python programming that you’ll use throughout your bioinformatics work:\n\nVariables help you store and manage data with meaningful names\nData types like numbers, strings, and booleans let you work with different kinds of biological data\nControl flow statements help your programs make decisions based on data\nBuilt-in functions provide essential tools for common programming tasks\n\nRemember:\n\nChoose clear, descriptive variable names\nBe mindful of data types when performing operations\nKeep conditional logic as simple as possible\nMake use of Python’s built-in functions for common tasks\n\nThese basics form the foundation for more advanced programming concepts we’ll explore in future tutorials. Practice working with these fundamentals – they’re the tools you’ll use to build more complex bioinformatics applications.\nDon’t worry if everything hasn’t clicked yet. Programming is a skill that develops with practice. Focus on understanding one concept at a time, and remember that you can always refer back to this tutorial as a reference.\nNext up, we’ll build on these basics to work with more complex data structures and write functions of our own!",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Basics</span>"
    ]
  },
  {
    "objectID": "chapters/02_collections.html",
    "href": "chapters/02_collections.html",
    "title": "2  Collections",
    "section": "",
    "text": "Introduction to Python Collections\nIn this tutorial, we’ll explore Python’s fundamental data structures and collections – the building blocks that help organize and analyze biological data effectively. From strings for handling DNA sequences to dictionaries for mapping genes to functions, you’ll learn how to use these tools through practical examples. We’ll cover when and why to use each type, giving you the foundation needed to tackle real bioinformatics problems.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "chapters/02_collections.html#introduction-to-python-collections",
    "href": "chapters/02_collections.html#introduction-to-python-collections",
    "title": "2  Collections",
    "section": "",
    "text": "What are collections?\nCollections in Python are containers that can hold multiple items, and provide convenient ways to store, access, and manipulate groups of related values.\nThink of collections like different types of containers:\n\nA list is like a row of boxes where you can store items in order\nA tuple is similar but locked/sealed (immutable)\nA dictionary is like a filing cabinet with labeled folders (keys) containing items (values)\nA range represents a sequence of numbers stored in an efficient way\n\nCollections let us:\n\nGroup related data together\nProcess multiple items efficiently\nOrganize information in meaningful ways\nAccess data using consistent patterns\n\n\n\nWhy we need different data structures\nPython provides different collection types because different tasks require different tools. For example:\n\nIf you need to store multiple DNA sequences in order and have fast access to them, use a List\nIf you need to group various pieces of data together and ensure they don’t change, use a Tuple\nIf you need to look up protein functions by their names, use a Dictionary\nIf you need to generate sample numbers efficiently, use a Range\n\nUsing the right data structure for the job optimizes both speed and code clarity. As we progress through this tutorial, you’ll learn which data structures work best in different situations.\n\n\nCommon Python Data Structures at a Glance\nWe will break down the specifics of each type soon, but let’s look first at a quick example of each type:\nA list is a mutable, ordered collection of items:\n\nnucleotides = [\"A\", \"T\", \"C\", \"G\"]\nprint(nucleotides)\n\n# This is a for loop. We will talk more about them below.\nfor nucleotide in nucleotides:\n    print(nucleotide)\n\n['A', 'T', 'C', 'G']\nA\nT\nC\nG\n\n\nA tuple is an immutable, ordered collection of items:\n\n# (name, code, molecular_weight)\nalanine = (\"Alanine\", \"Ala\", 89.1)\nprint(alanine)\n\n('Alanine', 'Ala', 89.1)\n\n\nA dictionary is a mapping from keys to values:\n\n# Dictionary -- key-value pairs (gene id -&gt; function)\ngene_functions = {\n    \"TP53\": \"tumor suppression\",\n    \"BRCA1\": \"DNA repair\",\n    \"INS\": \"insulin production\"\n}\nprint(gene_functions)\n\nfor gene, function in gene_functions.items():\n    print(f\"{gene} =&gt; {function}\")\n\n{'TP53': 'tumor suppression', 'BRCA1': 'DNA repair', 'INS': 'insulin production'}\nTP53 =&gt; tumor suppression\nBRCA1 =&gt; DNA repair\nINS =&gt; insulin production\n\n\nA range is a representation of a sequence of numbers:\n\n# 96 well plate positions\nsample_ids = range(1, 96)\nprint(sample_ids)\n\nrange(1, 96)\n\n\nNotice that each collection has a dedicated syntax for creating it. This makes it easy to create collections and gives you a visual cue for which collection you’re working with.\n\nLists are formed using square brackets ([])\nTuples are created with parentheses (())\nDictionaries use curly brackets ({}) and colons (:)\nRanges are generated by the range() function\n\nBeing able to recognize these collection types and know when to use each is critical to both writing and reading code. Let’s explore them further.\nNote: Python contains other useful data structures, including sets, but we won’t cover them in this tutorial.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "chapters/02_collections.html#strings",
    "href": "chapters/02_collections.html#strings",
    "title": "2  Collections",
    "section": "Strings",
    "text": "Strings\nIn Python, strings are ordered collections of characters, meaning they are sequences that can be indexed, sliced, and iterated over just like other sequence types (such as lists and tuples), with each character being an individual element in the collection.\nThough we covered strings in Tutorial 1, let’s go over some basics again so that you have it here for easy reference.\n\nString Literals\nIn Python, text data is handled with str objects, or strings. You can build strings with string literals:\n\n# With single quotes\n'a string'\n\n# With double quotes\n\"another string\"\n\n# Triple quoted\n\"\"\"Here is a string.\"\"\"\n'''And here is another.'''\n\n'And here is another.'\n\n\nIf you need to embed quote marks within a string literal, you can do something like this:\n\n# Double quote in single quoted string\n'This course is \"fun\", right?'\n\n# Single quote in double quoted string\n\"Of course! It's my favorite class!\"\n\n\"Of course! It's my favorite class!\"\n\n\nThere are also escape sequences for including different kinds of text inside a string literal. Tabs and newlines are some of the more common escape sequences:\n\n# Tabs\nprint(\"name\\tage\")\n\n# Newlines\nprint(\"gene 1\\ngene 2\")\n\nname    age\ngene 1\ngene 2\n\n\n\n\nString Methods\nIn addition to common operations like indexing, slicing, and concatenation, strings have a rich set of functionality provided by string methods.\nA string method is essentially a function that is “attached” to a string. Some common string methods are:\n\nupper, lower – Case conversion\nstrip, lstrip, rstrip – Remove whitespace\nsplit – Convert string to list based on delimiter\njoin – Combine list elements into string\nreplace – Replace substring\nfind, index – Find substring position\nstartswith, endswith – Check string prefixes/suffixes\ncount – Count substring occurrences\n\nLet’s go through them now.\n\nCase Conversion\nThe upper and lower methods convert strings to uppercase or lowercase. This is useful for standardizing text or making case-insensitive comparisons.\n\ndna = \"ATCGatcg\"\n\nprint(dna.upper())\nprint(dna.lower())\n\nfragment_1 = \"ACTG\"\nfragment_2 = \"actg\"\n\n# You can convert both sequences to lower case before\n# comparing them for a case-insensitive comparison.\nprint(fragment_1.lower() == fragment_2.lower())\n\nATCGATCG\natcgatcg\nTrue\n\n\n\n\nRemove Whitespace\nThe strip method remove whitespace characters (spaces, tabs, newlines). strip removes from both ends, while lstrip and rstrip remove from left or right only. This is particularly useful when cleaning up input data.\n\ndna_sequence = \"  ATCG\\n\"\nprint(dna_sequence.strip())\n\ngene_name = \"nrdA    \"\nprint(gene_name.rstrip())\n\nATCG\nnrdA\n\n\n\n\nConvert String To List\nThe split method divides a string into a list of substrings based on a delimiter. By default, it splits on whitespace. This is useful for parsing formatted data.\n\nfasta_header = \"&gt;sp|P00452|RIR1_ECOLI Ribonucleoside-diphosphate reductase 1\"\nfields = fasta_header.split(\"|\")\nprint(fields)\n\n['&gt;sp', 'P00452', 'RIR1_ECOLI Ribonucleoside-diphosphate reductase 1']\n\n\nCheck out this neat trick where Python will let us put the different fields directly into named variables.\n\n_, uniprot_id, protein_info = fasta_header.split(\"|\")\n\nprint(f\"{uniprot_id} =&gt; {protein_info}\")\n\nP00452 =&gt; RIR1_ECOLI Ribonucleoside-diphosphate reductase 1\n\n\nPretty useful! (We will see more about this in the section on tuples.)\n\n\nCombine List Into String\nThe join method combines a list of strings into one, using the string it’s called on as a delimiter. This is useful for creating formatted output.\n\namino_acids = [\"Met\", \"Gly\", \"Val\"]\nprotein = \"-\".join(amino_acids)\nprint(protein)\n\nfields = [\"GeneName\", \"Length\", \"Count\"]\ntsv_line = \"\\t\".join(fields)\nprint(tsv_line)\n\nMet-Gly-Val\nGeneName    Length  Count\n\n\n\n\nReplace Substring\nThe replace method substitutes all occurrences of a substring with another. This is helpful for sequence modifications or text cleanup, like turning a DNA string into an RNA string.\n\ndna = \"ATCGTTA\"\nrna = dna.replace(\"T\", \"U\")\nprint(rna)\n\nAUCGUUA\n\n\n\n\nFind Substring Position\nThe find and index methods locate the position of a substring. find returns -1 if not found, while index raises an error. These are useful for sequence analysis.\n\nsequence = \"ATCGCTAGCT\"\nposition = sequence.find(\"GCT\")\nprint(position)\n\ntry:\n    position = sequence.index(\"NNN\")\n    print(position)\nexcept ValueError:\n    print(\"not found!\")\n\n3\nnot found!\n\n\nDon’t worry too much now about this try/except construction for now – we will cover it in a later tutorial! Basically, it is a way to tell Python that we think an error may occur here, and if it does, what we should do to recover.\n\n\nCheck String Prefix/Suffix\nThe startswith and endswith methods check if a string begins or ends with a given substring. These are helpful for parsing user input, or validating sequence patterns and file names.\n\ngene = \"ATGCCGTAA\"\nprint(gene.startswith(\"ATG\"))\nprint(gene.endswith(\"TAA\"))\n\nTrue\nTrue\n\n\n\n\nCount Substring Occurrences\nThe count method counts how many times a substring appears in a string. This is useful for sequence analysis and pattern counting.\n\ndna = \"ATAGATAGATAG\"\ntag_count = dna.count(\"TAG\")\nprint(tag_count)\n\n3\n\n\n\n\n\nString Summary\nIn Python, strings are immutable sequences of characters (including letters, numbers, symbols, and spaces) that are used to store and manipulate text data. They can be created using single quotes (''), double quotes (\"\"), or triple quotes (''' ''' or \"\"\" \"\"\") and support various built-in methods for operations like searching, replacing, splitting, and formatting text.\n(For more info about string indexing, slicing, etc., see Tutorial 1.)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "chapters/02_collections.html#lists",
    "href": "chapters/02_collections.html#lists",
    "title": "2  Collections",
    "section": "Lists",
    "text": "Lists\nLists are going to be one of your best friends in Python – they’re flexible, easy to modify, and good for handling biological sequences and experimental data.\n\nCreating Lists\nYou can create lists using square brackets [] and assign them to variables. As always, keep in mind best practices for naming variables!\n\n# A DNA sequence\ndna_sequence = [\"A\", \"T\", \"G\", \"C\", \"T\", \"A\", \"G\"]\n\n# Gene names in a pathway\npathway_genes = [\"TP53\", \"MDM2\", \"CDKN1A\", \"BAX\"]\n\n# Expression values\nexpression_levels = [0.0, 1.2, 3.4, 2.1, 0.8]\n\n# Mixed data types (though it may be best to avoid mixing types like this)\nsample_info = [\"SAMPLE001\", 37.5, \"positive\", True]\n\n# Empty list to fill later\nresults = []\n\nCreating an empty list might seem a bit weird, but is actually common practice in Python – create an empty list and then use a loop to store multiple things in it. We will see examples of this later in the tutorial.\n\n\nList Indexing and Slicing\nRemember that a list is like a row of boxes, each with something inside. The boxes are in a particular order and each has a number that you can use to access the data inside (the index).\nYou could imagine a list looking something like this:\n┌─────┬─────┬─────┬─────┬─────┐\n│ \"A\" │ \"T\" │ \"G\" │ \"A\" │ \"C\" │  (values in the list)\n└─────┴─────┴─────┴─────┴─────┘\n   0     1     2     3     4     (indices of the values)\nWhich corresponds to the following Python code:\n\nnucleotides = [\"A\", \"T\", \"G\", \"A\", \"C\"]\n# index         0    1    2    3    4\n\nDon’t forget that Python starts counting with 0 rather than with 1.\nNote: For now, don’t worry too much right now about how Python stores items in a list. Later in the tutorial, we will adjust our mental model for collections.\n\nIndexing\nSimilar to strings, you can get specific things out of a list with list_name[] syntax, which is sometimes called “indexing” the list. The most basic option is to grab items one at time:\n\n# Get single elements\ndna = \"ATGC\"\nfirst_base = dna[0]\nthird_base = dna[2]\n\nJust like with strings, you can also start indexing from the end of a list. Try to predict the outcome before uncommenting the print() statement.\n\nmystery_base = dna[-1]\n# print(mystery_base)\n\n\n\nSlicing\nIf you want to get chunks of a list, you can use “slicing”:\n\ndna = \"ACTGactgACTG\"\nfirst_four = dna[0:4]\nmiddle_section = dna[4:8]\n\nprint(first_four)\nprint(middle_section)\n\nACTG\nactg\n\n\nYou can leave off the beginning or the end of a slice as well:\n\ndna = \"ACTGactgGGGG\"\n\n# From index 4 to the end\nprint(dna[4:])\n\n# From the beginning up to index 4, but *excluding* 4.\nprint(dna[:4])\n\nactgGGGG\nACTG\n\n\nSlices can get pretty fancy. Check this out:\n\ndna = \"AaTtCcGg\"\n\n# Get every other base, starting from the beginning.\nevery_second = dna[::2]\nprint(every_second)\n\n# Get every other base starting from index 1\nevery_other_second = dna[1::2]\nprint(every_other_second)\n\nATCG\natcg\n\n\nThere are quite a few rules about slicing, which can get a bit complicated. For this reason, it’s generally best to keep your slicing operations as simple as possible.\n\n\n\nList Methods\nSimilar to strings, lists come with some methods that let you modify them or get information about them. Some of the most common are:\n\nappend\ninsert\npop\nsort\ncount\n\nLet’s take a look.\n\nAdding Items to Lists\n\ngenes = [\"TP53\"]\n\n# Adds to the end\ngenes.append(\"BRCA1\")\n\n# Adds at specific position\ngenes.insert(0, \"MDM2\")\n\n# Adds multiple items\ngenes.extend([\"ATM\", \"PTEN\"])\n\nBased on the information in the comments, what does our list look like now? Try to figure that out before running the next code block.\n\nprint(genes)\n\n['MDM2', 'TP53', 'BRCA1', 'ATM', 'PTEN']\n\n\n\n\nRemoving Items from Lists\nWe know how to add items now, but what about removing them? There are several ways to do that as well:\n\ngenes = [\"MDM2\", \"TP53\", \"BRCA1\", \"ATM\", \"PTEN\"]\n\n# Removes by value\ngenes.remove(\"BRCA1\")\nprint(f\"remaining genes: {genes}\")\n\n# Removes and returns last item\nlast_gene = genes.pop()\nprint(f\"last_gene: {last_gene}, remaining genes: {genes}\")\n\n# Removes and returns item at index\nspecific_gene = genes.pop(0)\nprint(f\"specific_gene: {specific_gene}, remaining genes: {genes}\")\n\nremaining genes: ['MDM2', 'TP53', 'ATM', 'PTEN']\nlast_gene: PTEN, remaining genes: ['MDM2', 'TP53', 'ATM']\nspecific_gene: MDM2, remaining genes: ['TP53', 'ATM']\n\n\nPay attention to pop in particular. While remove just takes a value out of our list, pop removes the item and returns it, which is what allows us to save it to a variable.\n\n\nOther Useful List Methods\nThere are many other cool list methods. Here are a few more. Try to guess what the output will be before running the code block.\n\ngenes = [\"MDM2\", \"TP53\", \"BRCA1\", \"ATM\", \"PTEN\", \"TP53\"]\n\ngenes.sort()\nprint(genes)\n\ngenes.reverse()\nprint(genes)\n\nprint(genes.count(\"TP53\"))\n\n['ATM', 'BRCA1', 'MDM2', 'PTEN', 'TP53', 'TP53']\n['TP53', 'TP53', 'PTEN', 'MDM2', 'BRCA1', 'ATM']\n2\n\n\n\n\n\nList Operations\nWe talked about operators in Tutorial 1. These operators can also be applied to lists in various ways. Let’s check it out.\nSimilar to strings, you can concatenate lists into a single list using +:\n\nforward_primers = [\"ATCG\", \"GCTA\"]\nreverse_primers = [\"TAGC\", \"CGAT\"]\nall_primers = forward_primers + reverse_primers\nprint(all_primers)\n\n['ATCG', 'GCTA', 'TAGC', 'CGAT']\n\n\nTake a small list a “multiply” its components to make a bigger list using *:\n\n# Creates a poly-A sequence\npoly_a = [\"A\"] * 20\nprint(poly_a)\n\n['A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A', 'A']\n\n\nCheck if something is in a list using in:\n\ngenes = [\"MDM2\", \"TP53\", \"BRCA1\", \"ATM\", \"PTEN\", \"TP53\"]\n\n# Checking membership\nif \"TP53\" in genes:\n    print(\"TP53 present in our pathway\")\n\nif \"POLA\" in genes:\n    print(\"POLA is not found!\")\n\nTP53 present in our pathway\n\n\nAnd get the length of a list using len:\n\nsamples = [\"Treatment_1\", \"Control_1\", \"Treatment_2\", \"Control_2\"]\ntotal_samples = len(samples)\nprint(total_samples)\n\n4\n\n\n\n\nNested Lists\nLists can contain other lists, useful for representing things like matrices, graph connections, and simple hierarchical data.\n\n# Matrix\nsequences = [\n    [\"A\", \"T\", \"G\", \"C\"],\n    [\"G\", \"C\", \"T\", \"A\"],\n    [\"T\", \"A\", \"G\", \"C\"]\n]\nprint(sequences)\n\n# Coordinates\ncoordinates =[\n    [1, 2],\n    [3, 4],\n    [5, 6]\n]\nprint(coordinates)\n\n# Simple hierarchical data: Experimental data with replicates\nexpression_data = [\n    [\"Gene1\", [1.1, 1.2, 1.0]],  # Gene name and replicate values\n    [\"Gene2\", [2.1, 2.3, 1.9]],\n    [\"Gene3\", [0.5, 0.4, 0.6]]\n]\nprint(expression_data)\n\n[['A', 'T', 'G', 'C'], ['G', 'C', 'T', 'A'], ['T', 'A', 'G', 'C']]\n[[1, 2], [3, 4], [5, 6]]\n[['Gene1', [1.1, 1.2, 1.0]], ['Gene2', [2.1, 2.3, 1.9]], ['Gene3', [0.5, 0.4, 0.6]]]\n\n\nMany times, there will be a better solution to your problem than nesting lists in this way, but it’s something that you should be aware of should the need arise.\nNested lists can be accessed just like regular lists, but there will be more “layers” to get through depending on what you want out of them.\n\n# Accessing nested data\n\nfirst_sequence = sequences[0]\nprint(first_sequence)\n\ngene2_rep2 = expression_data[1][1][1]\nprint(gene2_rep2)\n\n['A', 'T', 'G', 'C']\n2.3\n\n\nLists are very flexible in Python, and so can be complicated. However, it will be good for you to get comfortable with Lists as they are one of the most commonly used data structures!\n\nWhat Does Python Actually Store in the List?\nWhen working with lists and other collections in Python, there’s a crucial detail about how Python manages data that might seem counterintuitive at first. Let’s explore this through a simple example using 2D points.\nFirst, let’s create some points and store them in a list:\n\n# Represent points as [x, y] coordinates\npoint_a = [0, 3]\npoint_b = [1, 2]\n\n# Store points in a list\npoints = [point_a, point_b]\nprint(points)\n\n[[0, 3], [1, 2]]\n\n\nWe can access individual coordinates using nested indexing:\n\n# Get the y-coordinate of the first point\nprint(points[0][1])\n# Get the x-coordinate of the second point\nprint(points[1][0])\n\n3\n1\n\n\nNow here’s where things get interesting. Let’s modify some values:\n\n# Double the y-coordinate of the first point\npoints[0][1] *= 2\nprint(points)\n\n# Now modify the original point_b\npoint_b[0] *= 10\nprint(point_b)\n\n# What do you think our points list looks like now?\nprint(points)\n\n# Also, we modified the first point via the list.\n# What do you think `point_a` variable now contains?\nprint(point_a)\n\n[[0, 6], [1, 2]]\n[10, 2]\n[[0, 6], [10, 2]]\n[0, 6]\n\n\nDid the last result surprise you? When we modified point_b, the change was reflected in our points list too! This happens because Python doesn’t actually store the values directly in the list – instead, it stores references (think of them as pointers) to the data. It’s like having a directory of addresses rather than copies of the actual data.\nUnderstanding this behavior is important because it means changes to your data in one place can unexpectedly affect the same data being used elsewhere in your code.\nWith this in mind, we can now update our mental model and make it a bit more accurate. This time, the items in the lists are references that “point” to the actual items we care about.\n  \"A\"   \"T\"   \"G\"   \"A\"   \"C\"    (items \"in\" the list are objects)\n   ↑     ↑     ↑     ↑     ↑\n┌──┴──┬──┴──┬──┴──┬──┴──┬──┴──┐\n│  ✦  │  ✦  │  ✦  │  ✦  │  ✦  │  (values in the list are references)\n└─────┴─────┴─────┴─────┴─────┘\n   0     1     2     3     4     (indices of the references)\nThe diagram for the points example might look something like this:\n    0     3       1     2      (items \"in\" the list are numbers)\n    ↑     ↑       ↑     ↑\n ┌──┴──┬──┴──┐ ┌──┴──┬──┴──┐\n │  ✦  │  ✦  │ │  ✦  │  ✦  │   (each element in `points` is also a list)\n └──┬──┴──┬──┘ └──┬──┴──┬──┘\n    ↑     ↑       ↑     ↑\n    └──┬──┘       └──┬──┘\n┌──────┴──────┬──────┴──────┐\n│      ✦      │      ✦      │  (the first level is the `points` list)\n└─────────────┴─────────────┘\nFor now, don’t get too hung up on the lower-level details – just be aware of the practical implications mentioned above.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "chapters/02_collections.html#loops",
    "href": "chapters/02_collections.html#loops",
    "title": "2  Collections",
    "section": "Loops",
    "text": "Loops\nSo far, we’ve worked with two types of collections: lists and strings. But what if you want to work with each element in these collections one at a time? That’s where loops come in!\nLoops give you a way to automate repetitive tasks. Instead of copying and pasting the same code multiple times to process each item in a list (which would be both tedious and error-prone), loops let you write the instructions once and apply them to every item automatically.\nFor example, if you had a list of gene sequences and wanted to check each one for a particular pattern, you wouldn’t want to write separate code for each sequence. A loop would let you perform this check systematically across your entire dataset.\nPython offers several different types of loops, each suited for particular situations. In this section we will focus on for loops and while loops.\n\nFor Loops\nA for loop processes each item in a sequence, one at a time. Think of it like going through a list and looking at each item one at a time:\n\nfor letter in [\"D\", \"N\", \"A\"]:\n    print(letter)\n\nD\nN\nA\n\n\nLet’s break that down:\n\nfor – tells Python we want to start a loop\nletter – a variable that will hold each item\nin [\"D\", \"N\", \"A\"] – tells Python to loop through the list [\"D\", \"N\", \"A\"]\n: – marks the beginning of the code block to be executed\nThe indented code (print(letter)) runs once for each item\n\nNote that for and in are specifically required in for loop syntax. letter and [\"D\", \"N\", \"A\"] will change depending on the context.\nFor example, this loop has the same behavior as the previous loop:\n\nletters = [\"D\", \"N\", \"A\"]\nfor the_letter in letters:\n    print(the_letter)\n\nD\nN\nA\n\n\nThis time, we used a different variable name to store the items of the collection, and rather than putting the collection directly in the for ... in ... : part, we referred to the collection using a variable.\nIn addition to lists, for loops also work on strings:\n\nnucleotides = \"ATCG\"\nfor nucleotide in nucleotides:\n    print(f\"The nucleotide was '{nucleotide}'\")\n\nThe nucleotide was 'A'\nThe nucleotide was 'T'\nThe nucleotide was 'C'\nThe nucleotide was 'G'\n\n\nYou can actually use for loops on lots of different Python data structures: as long as it is iterable, then you can use a for loop with it.\nOften you will want to take some action multiple times. For this, we can use range:\n\nfor number in range(5):\n    print(number)\n\n0\n1\n2\n3\n4\n\n\nThis should have printed 5 numbers: 0, 1, 2, 3, 4. Here is Python counting from zero again!\nYou can also tell range where to start and stop:\n\n# Count from 1 to 5\nfor number in range(1, 6):\n    print(number)\n\n1\n2\n3\n4\n5\n\n\nHere is a neat thing you can do with ranges. Before running the code, could you guess what it might do?\n\nfor i in range(2, 10, 2):\n    print(i)\n\n2\n4\n6\n8\n\n\nLet’s break down what’s happening with range here. While we’ve seen range create simple sequences of numbers before, it can actually take up to three arguments: range(start, stop, step). The step tells Python how many numbers to count by each time.\nIt’s like counting: normally we count “1, 2, 3, 4…” (step of 1), but sometimes we count “2, 4, 6, 8…” (step of 2). In this example, we’re using a step of 2 to skip every other number.\nThe start and step arguments are optional – you can just use range(stop) if you want to count normally starting from zero. If you’re curious about more advanced uses, like counting backwards or working with negative numbers, check out the Python range docs for more details.\nRanges are memory efficient – they don’t store all the numbers in the range in memory. This is important when generating large batches of numbers.\n(This code shouldn’t be run. It’s just here to illustrate the point.)\nbig_range = range(1, 1000000)  # Takes very little memory\nbig_list = list(big_range)     # Takes much more memory!\n\nNested For Loops\nOne feature of for loops is that you can put one inside another – something we call “nesting”. Think of it like those Russian nesting dolls, where each doll contains a smaller one inside.\n\nfor i in range(2):\n    for j in range(3):\n        print(f\"i: {i}; j: {j}\")\n\ni: 0; j: 0\ni: 0; j: 1\ni: 0; j: 2\ni: 1; j: 0\ni: 1; j: 1\ni: 1; j: 2\n\n\nLet’s break down what’s happening here. The outer loop (using i) runs two times (0, 1), and for each of those times, the inner loop (using j) runs three times (0, 1, 2). It’s a bit like having a set of drawers where you check each drawer (outer loop), and within each drawer, you look at every item inside (inner loop).\nWhen you run the above code, you’ll see each combination of i and j printed out, showing how the loops work together. This pattern of nested loops is incredibly useful when you need to process data that has multiple levels or dimensions, for example, like comparing every gene in one dataset to every gene in another dataset.\nHere is a schematic view:\n┌──────────────────────────────────────────────┐\n│ i=0                                          │\n│ ┌────────────┐ ┌────────────┐ ┌────────────┐ │\n│ │ j=0        │ │ j=1        │ │ j=2        │ │\n│ │            │ │            │ │            │ │\n│ │ print(...) │ │ print(...) │ │ print(...) │ │\n│ └────────────┘ └────────────┘ └────────────┘ │\n└──────────────────────────────────────────────┘\n\n┌──────────────────────────────────────────────┐\n│ i=1                                          │\n│ ┌────────────┐ ┌────────────┐ ┌────────────┐ │\n│ │ j=0        │ │ j=1        │ │ j=2        │ │\n│ │            │ │            │ │            │ │\n│ │ print(...) │ │ print(...) │ │ print(...) │ │\n│ └────────────┘ └────────────┘ └────────────┘ │\n└──────────────────────────────────────────────┘\nYou can have more than two levels of nesting. For example:\n\nfor i in range(2):\n    for j in range(3):\n        for k in range(4):\n            print(f\"i: {i}; j: {j}; k: {k}\")\n\ni: 0; j: 0; k: 0\ni: 0; j: 0; k: 1\ni: 0; j: 0; k: 2\ni: 0; j: 0; k: 3\ni: 0; j: 1; k: 0\ni: 0; j: 1; k: 1\ni: 0; j: 1; k: 2\ni: 0; j: 1; k: 3\ni: 0; j: 2; k: 0\ni: 0; j: 2; k: 1\ni: 0; j: 2; k: 2\ni: 0; j: 2; k: 3\ni: 1; j: 0; k: 0\ni: 1; j: 0; k: 1\ni: 1; j: 0; k: 2\ni: 1; j: 0; k: 3\ni: 1; j: 1; k: 0\ni: 1; j: 1; k: 1\ni: 1; j: 1; k: 2\ni: 1; j: 1; k: 3\ni: 1; j: 2; k: 0\ni: 1; j: 2; k: 1\ni: 1; j: 2; k: 2\ni: 1; j: 2; k: 3\n\n\nThough I bet you know what’s going on with nested loops by now, let’s break it down anyway. The innermost loop (k) completes all its iterations before the middle loop (j) counts up once, and the middle loop completes all its iterations before the outer loop (i) counts up once. In this example, for each value of i, we’ll go through all values of j, and for each of those, we’ll go through all values of k.\nRemember that each additional level of nesting multiplies the number of iterations. In our example, we have 2 × 3 × 4 = 24 total iterations. Keep this in mind when working with larger datasets.\n\n\nEnumerated for Loops\nSometimes when you’re working with a sequence, you need to know not just what each item is, but also where it appears. That’s where Python’s handy enumerate function comes in. It lets you track both the position (index) and the value of each item as you loop through them.\nHere’s a simple example:\n\nfor index, letter in enumerate(\"ABCDE\"):\n    print(f\"index: {index}; letter: {letter}\")\n\nindex: 0; letter: A\nindex: 1; letter: B\nindex: 2; letter: C\nindex: 3; letter: D\nindex: 4; letter: E\n\n\nThis will show you each letter along with its position in the sequence, starting from 0 (remember, Python always starts counting at 0!).\nBy the way, you can also use enumerate outside of loops. For instance, if you have a list of nucleotides:\n\nnucleotides = [\"A\", \"C\", \"T\", \"G\"]\nenumerated_nucleotides = enumerate(nucleotides)\nprint(list(enumerated_nucleotides))\n\n[(0, 'A'), (1, 'C'), (2, 'T'), (3, 'G')]\n\n\nThis creates pairs of positions and values, which can be useful, say, when you need to track where certain elements appear in your sequence data.\n\n\n\nWhile Loops\nWhile loops keep repeating until the given condition is not true (or truthy). Let’s look at a simple example that counts from 1 to 5:\n\ncount = 1\nwhile count &lt;= 5:\n    print(count)\n    count += 1\n\n1\n2\n3\n4\n5\n\n\nTo understand what this loop does, imagine it following a simple set of instructions:\n\nCreate a variable called count and set it to 1.\nThen, keep doing these steps as long as count is less than or equal to 5:\n\nDisplay the current value of count\nAdd 1 to count.\n\n\nThe loop will keep running until count becomes 6, at which point the condition count &lt;= 5 becomes false, and the loop stops.\nJust to make it super clear, let’s write out the steps:\n\ncount = 1: is count &lt;= 5? Yes! prints 1, then adds 1\ncount = 2: is count &lt;= 5? Yes! prints 2, then adds 1\ncount = 3: is count &lt;= 5? Yes! prints 3, then adds 1\ncount = 4: is count &lt;= 5? Yes! prints 4, then adds 1\ncount = 5: is count &lt;= 5? Yes! prints 5, then adds 1\ncount = 6: is count &lt;= 5? No! stops because 6 is not &lt;= 5\n\n\nInfinite Loops and Other Problems\nWhen working with while loops, it’s crucial to ensure your loop has a way to end. Think of it like setting up an automated process – you need a clear stopping point, or the process will run forever!\nThere are two common pitfalls to watch out for:\n\nIf your condition is never true to begin with, the loop won’t run at all\nIf your condition can never become false, the loop will run forever (called an infinite loop)\n\nHere’s an example of the 2nd problem. Can you figure out why this code would run forever?\n# Infinite loop -- DO NOT RUN!!\ncount = 1\nwhile count &gt;= 0:\n    print(count)\n    count = count + 1\nLet’s think through what’s happening:\n\nWe start with count = 1\nThe loop continues as long as count is greater than or equal to 0\nEach time through the loop, we’re adding 1 to count\nSo count keeps getting bigger: 1, 2, 3, 4, 5…\nBut wait! A number that keeps getting bigger will always be greater than 0\nThis means our condition (count &gt;= 0) will always be true, and the loop will never end!\n\nWhen writing your own loops, always be sure that your condition will eventually become false – you need a clear endpoint!\n\n\n\nModifying a List While Looping\nOne tricky aspect of using loops in Python occurs if you try to modify a collection while looping over it.\nWith a while loop and the pop method, it’s not too weird – you run the while loop until the list is empty:\n\n# Starting with a list of tasks\ntodo_list = [\"task1\", \"task2\", \"task3\"]\n\nwhile todo_list:  # This is true as long as the list has items\n    current_task = todo_list.pop()  # removes and returns last item\n    print(f\"Doing task: {current_task}\")\n\nprint(\"All tasks complete!\")\nprint(todo_list)\n\nDoing task: task3\nDoing task: task2\nDoing task: task1\nAll tasks complete!\n[]\n\n\nHowever, things can get quite weird with for loops:\n\n# This is probably not what you want!\nnumbers = [1, 2, 3, 4, 5]\nfor number in numbers:\n    numbers.remove(number)  # Don't do this!\nprint(numbers)\n\n[2, 4]\n\n\nUnfortunately, that did not remove all the items from numbers like you may have expected.\nOne way to address this issue is to use [:] to create a copy of numbers and iterate over that collection. Meanwhile, you remove items from the original numbers.\n\nnumbers = [1, 2, 3, 4, 5]\nfor number in numbers[:]:  # The [:] creates a copy\n    numbers.remove(number)\n    print(f\"Removed {number}. List is now: {numbers}\")\nprint(f\"at the end: {numbers}\")\n\nRemoved 1. List is now: [2, 3, 4, 5]\nRemoved 2. List is now: [3, 4, 5]\nRemoved 3. List is now: [4, 5]\nRemoved 4. List is now: [5]\nRemoved 5. List is now: []\nat the end: []\n\n\nReally, this example is pretty artificial – you wouldn’t be trying to delete every item in a list with a for loop anyway. Just be aware that if you modify a collection during a loop, special care must be taken to ensure that you don’t mess things up.\nTake note of this for miniproject 1 – you will “probably” have to remove some items from a list to complete it! But don’t worry, you will see some more examples in the project description….\n\n\nComprehensions\nWhile we are on the topic of loops, let’s discuss one more thing: Comprehensions.\nComprehensions let you create new lists (and other collections) from existing lists (and other collections).\nLet’s say that you want to create a list of RNA bases and you’ve already made a list of DNA bases. One way to do this would be to take your existing list and convert any Thymines (T) to Uracils (U). We can do this with a traditional for loop:\n\n# Using traditional loop\ndna = [\"A\", \"T\", \"G\", \"C\"]\nrna = []\nfor base in dna:\n    if base != \"T\":\n        rna.append(base)\n    else:\n        rna.append(\"U\")\n\nprint(rna)\n\n['A', 'U', 'G', 'C']\n\n\nOr with a comprehension:\n\ndna = \"ATGC\"\nrna = [\"U\" if base == \"T\" else base for base in dna]\nprint(rna)\n\n['A', 'U', 'G', 'C']\n\n\nThe comprehension is much more concise! The list comprehension is doing everything that the traditional for loop is doing, but in a single line.\nThe basic structure of a comprehension can be broken down into these components:\nnew_list = [expression for item in iterable if condition]\nBreaking it down:\n\nnew_list: The resulting list\nexpression: What you want to do with each item (like transform it)\nfor item in iterable: The loop over some iterable object\nif condition: Optional filter (you can leave this out)\n\nNote that in our original example, the if condition actually came before the for loop part – that’s allowed!\nComprehensions are definitely weird at first! Let’s look at some more examples.\nHere is a basic example using range instead of an existing list:\n\nsquares = [x**2 for x in range(5)]\nprint(squares)\n\n# Same as:\nsquares = []\nfor x in range(5):\n    squares.append(x**2)\n\nprint(squares)\n\n[0, 1, 4, 9, 16]\n[0, 1, 4, 9, 16]\n\n\nThis example takes each number in the list produced by range(5), squares it, and adds it to the new list squares. In this case:\n\nsquares is the new_list\nx**2 is the expression\nx is the item and range(5) is the iterable\nThere is no if condition\n\nNotice that you don’t have to initialize an empty list for the comprehension to work – it makes the list itself, unlike with a for loop.\nLet’s look at an example with a condition:\n\n# Using comprehension\nexpressions = [1.2, 0.5, 3.4, 0.1, 2.2]\nhigh_expression = [x for x in expressions if x &gt; 2.0]\nprint(high_expression)\n\n# Using a for loop\nexpressions = [1.2, 0.5, 3.4, 0.1, 2.2]\nhigh_expression = []\nfor x in expressions:\n    if x &gt; 2.0:\n        high_expression.append(x)\nprint(high_expression)\n\n[3.4, 2.2]\n[3.4, 2.2]\n\n\nIn this example, we take an existing list, expressions, and make a new list, high_expressions, that contains only the expressions that are 2.0 or greater.\nNotice that in this example, there is nothing done to the existing items in the list before adding them to the new one, which is why the comprehension starts with x for x.\nComprehensions can also be used to create dictionaries. Check this out:\n\nsquares = {x: x**2 for x in range(5)}\nprint(squares)\n\neven_squares = {x: x**2 for x in range(5) if x % 2 == 0}\nprint(even_squares)\n\n{0: 0, 1: 1, 2: 4, 3: 9, 4: 16}\n{0: 0, 2: 4, 4: 16}\n\n\nThat is pretty neat right?\nWhile comprehensions are compact, whether or not you think this conciseness leads to better code is a different story. As you gain more experience, you will get a better feel for such things. Whether you use them a lot or a little, you should be aware of them as they are quite common in Python codebases.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "chapters/02_collections.html#tuples",
    "href": "chapters/02_collections.html#tuples",
    "title": "2  Collections",
    "section": "Tuples",
    "text": "Tuples\nTuples are like lists that can’t be changed – perfect for storing fixed information. We often use tuples when we want to ensure data integrity or represent relationships that shouldn’t change.\n\nCreating Tuples\nTuples have a dedicated syntax used for construction:\n\nletters = (\"a\", \"b\", \"c\")\n\n# Single item tuples still need a comma!\nnumber = (1, )\n\nThe syntax for creating a tuple is not that different from creating a list, but you’ll notice differences when trying to alter their components. For example, the following code would raise an error if we didn’t put the try/except around it:\n\nletters = (\"a\", \"b\", \"c\")\n\ntry:\n    letters[0] = \"d\"\nexcept TypeError:\n    print(\"you can't assign to a tuple\")\n\nyou can't assign to a tuple\n\n\nIf letters was a list, the above code would change the list to start with d instead of b. Instead, we got an error. This is because tuples are immutable.\nWhether some data is mutable or immutable determines whether you can modify it or not. Here is a silly metaphor to illustrate what I mean:\n\nMutable collections (like lists and dictionaries) are like erasable whiteboards – you can add, remove, or change items whenever you need to\nImmutable collections (like tuples) are more like carved stone tablets – once created, their contents are “set in stone”\n\nWhy does this matter? Here are two practical implications:\n\nData Safety: Immutable collections help prevent accidental changes to important data\n\nRemember how we could modify individual coordinates in our list earlier? If we had used tuples instead, Python would have prevented any accidental modifications\n\nTechnical Requirements: Some Python features, like using values as dictionary keys (which we’ll explore soon), only work with immutable data types\n\nTuples excel at representing fixed relationships between values that logically belong together. Think of them as a way to package related information that you know shouldn’t change during your program’s execution.\nE.g., our coordinates example from above could be better written with a tuple:\n\n# (x, y)\npoint = (1, 2)\nprint(point)\n\n(1, 2)\n\n\nOr, you could represent facts about a codon as a tuple:\n\nmethionine = (\"Methionine\", \"Met\", \"M\", \"ATG\")\nprint(methionine)\n\n('Methionine', 'Met', 'M', 'ATG')\n\n\nOr, you could represent related gene information:\n\ngene_info = (\"BRCA1\",     # gene name\n             \"chr17\",     # chromosome\n             43044295,    # start position\n             43125364,    # end position\n             \"plus\")      # strand\nprint(gene_info)\n\n('BRCA1', 'chr17', 43044295, 43125364, 'plus')\n\n\n\n\nTuple Packing and Unpacking\nLet’s look at two really useful Python features that make working with multiple values easier: tuple packing and unpacking.\nTuple packing is pretty straightforward – Python can automatically bundle multiple values into a tuple for you. Here’s an example using a codon and its properties:\n\n# Packing values into a tuple\ncodon = \"AUG\", \"Methionine\", \"Start\"\nprint(codon)\n\n('AUG', 'Methionine', 'Start')\n\n\nThe opposite operation, tuple unpacking, lets you smoothly assign tuple elements to separate variables:\n\n# Unpacking a tuple into individual variables\ncodon = (\"AUG\", \"Methionine\", \"Start\")\nsequence, amino_acid, role = codon\n\nprint(f\"Codon: {sequence}; Amino Acid: {amino_acid}; Role: {role}\")\n\nCodon: AUG; Amino Acid: Methionine; Role: Start\n\n\nOne of the coolest applications of packing and unpacking is swapping values between variables. Check this out:\n\n# Set initial values\nx, y = 1, 2\n\n# Print the original values\nprint(f\"x: {x}; y: {y}\")\n\n# Swap values in one clean line\nx, y = y, x\n\n# Print the swapped values\nprint(f\"x: {x}; y: {y}\")\n\nx: 1; y: 2\nx: 2; y: 1\n\n\nTo appreciate how nice this is, here’s how you’d typically swap values in many other programming languages:\n\nx = 1\ny = 2\n\n# Print the original values\nprint(f\"x: {x}; y: {y}\")\n\n# The traditional way requires a temporary variable\ntmp = y\ny = x\nx = tmp\n\n# Print the swapped values\nprint(f\"x: {x}; y: {y}\")\n\nx: 1; y: 2\nx: 2; y: 1\n\n\nPython’s packing and unpacking syntax makes this common operation more intuitive and readable. Instead of juggling a temporary variable, you can swap values in a single, clear line of code. This is just one example of how Python’s design choices can make your code both simpler to write and easier to understand.\n\n\nNamed Tuples\nYou may be thinking that it could get tricky to remember which field of a tuple is which. Named tuples provide a great way to address this. They’re like regular tuples, but with the added benefit of letting you create them and access data using descriptive names instead of index numbers.\nLet’s see how they work:\n\n# We need to import namedtuple from the collections module\nfrom collections import namedtuple\n\n# Create a Gene type with labeled fields\n# (note the name is Gene and not gene)\nGene = namedtuple(\"Gene\", \"name chromosome start stop\")\n\n# Create a specific gene entry\n#\n# Using named arguments can keep you from mixing up the arguments!\ntp53 = Gene(\n    name=\"TP53\",\n    chromosome=\"chr17\",\n    start=7_571_720,\n    stop=7_590_868,\n)\n\n# Access the data using meaningful names\nprint(tp53.name)\nprint(tp53.chromosome)\n\n# You can still unpack it like a regular tuple if you want\nname, chromosome, start, stop = tp53\nprint(name, chromosome, start, stop)\n\nTP53\nchr17\nTP53 chr17 7571720 7590868\n\n\nWhat makes named tuples great?\n\nThey’re clear and self-documenting – the labels tell you exactly what each value means\nThey’re less prone to errors – no more mixing up whether position 2 was start or stop\nThey’re efficient and unchangeable (immutable), just like regular tuples\n\nFor example, you can’t change values after creation:\n\ntry:\n    tp53.start = 1300  # This will raise an error\nexcept AttributeError:\n    print(\"you can't do this!\")\n\nyou can't do this!\n\n\nNamed tuples are perfect for representing any kind of structured data. Here’s another example using DNA sequences:\n\nSequence = namedtuple(\"Sequence\", \"id dna length gc_content\")\n\n# Create some sequence records\nseq1 = Sequence(\"SEQ1\", \"GGCTAA\", length=6, gc_content=0.5)\nseq2 = Sequence(\"SEQ2\", \"GGTTAA\", length=6, gc_content=0.33)\n\n# Named tuples print out nicely too\nprint(seq1)  # Shows all fields with their values\nprint(seq2)\n\nSequence(id='SEQ1', dna='GGCTAA', length=6, gc_content=0.5)\nSequence(id='SEQ2', dna='GGTTAA', length=6, gc_content=0.33)\n\n\nI have mentioned a few times now that tuples are immutable, and named tuples are as well. There is a way to get an modified copy of a named tuple however:\n\nseq1 = Sequence(\"SEQ1\", \"GGCTAA\", length=6, gc_content=0.5)\n\nseq1_with_new_id = seq1._replace(id=\"sequence 1\")\n\n# The original seq1 is unchanged:\nprint(seq1)\n\n# The new one has the same values as the original other than the id\nprint(seq1_with_new_id)\n\nSequence(id='SEQ1', dna='GGCTAA', length=6, gc_content=0.5)\nSequence(id='sequence 1', dna='GGCTAA', length=6, gc_content=0.5)\n\n\nThe bottom line: When you need to bundle related data together, named tuples are often a great choice. They’re essentially as lightweight as regular tuples, but they make your code much easier to read and maintain. Think of them as regular tuples with the added bonus of built-in documentation!\n\n\nWhen to Use Tuples vs. Lists\nIt may still be unclear when to choose tuples rather than lists. While you will get a feel for it over time, here are some guidelines that can help you choose:\nChoose a Tuple When:\n\nYour data represents an inherent relationship that won’t change (like a DNA sequence’s start and end coordinates)\nYou want to make sure your data stays protected from accidental modifications\nYou need to use the data as a dictionary key (we’ll explore this more soon)\nYou’re returning multiple related values from a function\n\nChoose a List When:\n\nYou’ll need to add or remove items as your program runs\nYour data needs to be flexible and modifiable\nYou’re accumulating or building up data throughout your program\n\nOne way to think of it is: if you’re working with data that should remain constant, reach for a tuple. If you need something more flexible that can grow or change (like collecting results), a list is your better choice.\nHere is a nice section of the Python docs if you want to dive deeper: Why are there separate tuple and list data types?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "chapters/02_collections.html#dictionaries",
    "href": "chapters/02_collections.html#dictionaries",
    "title": "2  Collections",
    "section": "Dictionaries",
    "text": "Dictionaries\nDictionaries in Python are a bit like address books. Just as you can look up someone’s phone number using their name, dictionaries let you pair up pieces of information so you can easily find one when you know the other. The first part (like the person’s name) is called the key, and it leads you to the second part (like their phone number), which is called the value.\nLet’s say you want to keep track of gene names and their functions. Instead of scanning through a long list every time, a dictionary lets you jump straight to the function just by knowing the gene name. They are a great way to organize and retrieve your data quickly.\n\nCreating Dictionaries\n\nDictionary Literals ({})\nThe most straightforward way to create dictionaries is using curly brackets {} with key: value pairs:\n\ncodon_table = {\n    \"AUG\": \"Met\",\n    \"UAA\": \"Stop\",\n    \"UAG\": \"Stop\",\n    \"UGA\": \"Stop\"\n}\n\nprint(codon_table)\n\n{'AUG': 'Met', 'UAA': 'Stop', 'UAG': 'Stop', 'UGA': 'Stop'}\n\n\n\n\ndict Function\nYou can also create dictionaries using the dict() function, which is particularly nice when you have simple string keys:\n\ngene = dict(gene=\"nrdA\", product=\"ribonucleotide reductase\")\nprint(gene)\n\n{'gene': 'nrdA', 'product': 'ribonucleotide reductase'}\n\n\n\n\ndict + zip\nHere’s a handy trick: if you have two separate lists that you want to pair up into a dictionary, you can use zip with dict:\n\ngenes = [\"TP53\", \"BRCA1\", \"KRAS\"]\nfunctions = [\"tumor suppressor\", \"DNA repair\", \"signal transduction\"]\n\ngene_functions = dict(zip(genes, functions))\n\nprint(gene_functions)\n\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'KRAS': 'signal transduction'}\n\n\nThe order matters when using zip – the first list provides the keys, and the second list provides the values:\n\n# Switching the order gives us a different dictionary\nmysterious_dictionary = dict(zip(functions, genes))\nprint(mysterious_dictionary)\n\n{'tumor suppressor': 'TP53', 'DNA repair': 'BRCA1', 'signal transduction': 'KRAS'}\n\n\n\n\nOne Entry at a Time\nYou can also built up dictionaries one value at a time. Here’s a common real-world scenario: you’re reading data from a file and need to build a dictionary as you go.\nFor this example, imagine that lines came from parsing a file rather than being hardcoded.\n\n# This could be data from a file\nlines = [\n    [\"TP53\", \"tumor suppressor\"],\n    [\"BRCA1\", \"DNA repair\"],\n    [\"KRAS\", \"signal transduction\"],\n]\n\n# Start with an empty dictionary\ngene_functions = {}\n\n# Add each item to the dictionary\nfor gene_name, function in lines:\n    gene_functions[gene_name] = function\n\nprint(gene_functions)\n\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'KRAS': 'signal transduction'}\n\n\nThis pattern of building a dictionary piece by piece is something you’ll use frequently when working with real data. It’s especially useful when processing files or API responses where you don’t know the contents ahead of time.\n\n\nDuplicate Keys & Values\nA few important things to know about dictionaries:\n\nValues can be repeated (the same value can appear multiple times)\nKeys must be unique (if you try to use the same key twice, only the last value will be kept)\n\nHere’s an example showing both of these properties:\n\n# Values can be repeated\nprint(dict(a=\"apple\", b=\"banana\", c=\"apple\"))\n\n# Only the last value for a repeated key is kept\ncodons = {\n    \"AUG\": \"Met\",\n    \"UAA\": \"Stop\",\n    \"UAG\": \"Stop\",\n    \"UGA\": \"Stop\",\n    \"AUG\": \"Methionine\",  # This will override the first AUG entry\n}\nprint(codons)\n\n{'a': 'apple', 'b': 'banana', 'c': 'apple'}\n{'AUG': 'Methionine', 'UAA': 'Stop', 'UAG': 'Stop', 'UGA': 'Stop'}\n\n\n\n\n\nWorking with Dictionaries: Getting, Adding, and Removing Items\nLet’s see the basics of working with dictionaries in Python. We’ll continue with our gene_functions dictionary from earlier:\n\ngenes = [\"TP53\", \"BRCA1\", \"KRAS\"]\nfunctions = [\"tumor suppressor\", \"DNA repair\", \"signal transduction\"]\ngene_functions = dict(zip(genes, functions))\nprint(gene_functions)\n\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'KRAS': 'signal transduction'}\n\n\n\nGetting Items from a Dictionary\nThe most basic way to look up information in a dictionary is similar to how you’d look up a word in a real dictionary: you use the key to find the value. In Python, this means using square brackets:\n\n# Looking up a value\np53_function = gene_functions[\"TP53\"]\nprint(p53_function)\n\ntumor suppressor\n\n\nTrying to find a key that doesn’t exist will cause an error. (Again, we wrap the code that will cause an error in a try/except block so that it doesn’t break our notebook code.)\n\ntry:\n    gene_functions[\"apple pie\"]\nexcept KeyError:\n    print(\"there is no gene called 'apple pie'\")\n\nthere is no gene called 'apple pie'\n\n\nThere is an alternative way to get info from a dictionary that will not raise an error if the key you’re searching for is not found: get.\n\n# This will return `None` rather than raise an error\n# if the key is not found\nresult = gene_functions.get(\"BRCA2\")\nprint(result)\n\n# This will return the value \"Unknown\"\n# if the key is not found\nresult = gene_functions.get(\"BRCA2\", \"Unknown\")\nprint(result)\n\nNone\nUnknown\n\n\n\n\nAdding Items to a Dictionary\nWe mentioned that dictionaries are mutable. Let’s see how to add items to our dictionary. You can either add items one at a time or several at once:\n\n# Adding a single new entry\ngene_functions[\"EGFR\"] = \"growth signaling\"\nprint(gene_functions)\n\n# Adding multiple entries at once\ngene_functions.update({\n    \"MDM2\": \"p53 regulation\",\n    \"BCL2\": \"apoptosis regulation\"\n})\nprint(gene_functions)\n\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'KRAS': 'signal transduction', 'EGFR': 'growth signaling'}\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'KRAS': 'signal transduction', 'EGFR': 'growth signaling', 'MDM2': 'p53 regulation', 'BCL2': 'apoptosis regulation'}\n\n\nYou can get a bit fancy with updating dictionaries if you want by using operators:\n\nletters_and_numbers = dict(a=1, b=2) | dict(a=10, c=30)\nprint(letters_and_numbers)\n\nletters_and_numbers |= dict(d=400, e=500)\nprint(letters_and_numbers)\n\n{'a': 10, 'b': 2, 'c': 30}\n{'a': 10, 'b': 2, 'c': 30, 'd': 400, 'e': 500}\n\n\nWhen you’re learning to code, it’s best to stick with straightforward, easy-to-read solutions. While Python offers some fancy shortcuts (like complex operators), you’ll usually want to write code that you and others can easily understand later. Simple and longer is often better than shorter and clever!\nHere’s an interesting feature of Python dictionaries that you might have noticed: when you print out a dictionary, the items appear in the exact order you added them. This wasn’t always true in older versions of Python, but now dictionaries automatically keep track of the order of your entries.\nOne final thing to mention. You can’t use every Python type as a dictionary key, only immutable types. E.g., you couldn’t use a list as a key for a dictionary. The specific reason for that is beyond the scope of this tutorial, but you may be interested in reading more about it here: Why must dictionary keys be immutable?\n\n\nRemoving Items from a Dictionary\nNeed to remove something from your dictionary? Here are two options:\n\n# Remove an entry with del.\n#\n# del will raise an error if the key is not present\ntry:\n    del gene_functions[\"KRAS\"]\nexcept KeyError:\n    print(\"KRAS was not present in the dictionary\")\nprint(gene_functions)\n\n# Remove and save the value with pop()\n#\n# We add the \"Unknown\" to the call to pop so that our program\n# will still run if the key is not present.\nremoved_gene = gene_functions.pop(\"EGFR\", \"Unknown\")\nprint(f\"Removed function: {removed_gene}\")\nprint(gene_functions)\n\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'EGFR': 'growth signaling', 'MDM2': 'p53 regulation', 'BCL2': 'apoptosis regulation'}\nRemoved function: growth signaling\n{'TP53': 'tumor suppressor', 'BRCA1': 'DNA repair', 'MDM2': 'p53 regulation', 'BCL2': 'apoptosis regulation'}\n\n\nThe del statement is probably the more common way to remove an item from a dictionary.\nNote that if you run that code block more than one time, you will get different outputs. Can you think of why that would be?\nBy the way…before working with a key, it’s often wise to first check if it exists:\n\nif \"TP53\" in gene_functions:\n    print(\"Found TP53's function!\")\n    function = gene_functions[\"TP53\"]\nelse:\n    print(\"TP53 not found in our dictionary\")\n\nFound TP53's function!\n\n\nThis same technique is a good idea before using del as well, since del will give you an error if you try to delete the value of a key that is not present in the dictionary.\n\nif \"TP53\" in gene_functions:\n    del gene_functions[\"TP53\"]\n    print(gene_functions)\nelse:\n    print(\"TP53 not found in our dictionary\")\n\n{'BRCA1': 'DNA repair', 'MDM2': 'p53 regulation', 'BCL2': 'apoptosis regulation'}\n\n\nNote the use of the in operator. It is for membership testing and also works with dictionaries.\n\n\nExample: Creating the Reverse Complement of a DNA Sequence\nLet’s tackle a common task in DNA sequence analysis: generating a reverse complement. If you’ve worked with DNA before, you know that A pairs with T, and C pairs with G.\nFirst, we’ll create a dictionary that maps each nucleotide to its complement:\n\ncomplement = {\"A\": \"T\", \"T\": \"A\", \"G\": \"C\", \"C\": \"G\"}\nprint(complement)\n\n{'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G'}\n\n\nThen, we’ll take a simple DNA sequence to demonstrate:\n\ndna_sequence = \"AACCTTGG\"\n\nFinally, we’ll loop through the sequence backwards (that’s what reversed(...) does) and look the complement of each nucleotide:\n\nfor nucleotide in reversed(dna_sequence):\n    print(complement[nucleotide], end=\"\")\n\nCCAAGGTT\n\n\n(The end=\"\" parameter tells Python not to add newlines between letters, giving us one continuous sequence.)\n\n\n\nNested Dictionaries: Organizing Complex Data\nWhile simple dictionaries work well for simple mappings like mapping the name of a gene to its function, biological data often has multiple layers of related information.\nLet’s look at one way we can organize this richer data using nested dictionaries – dictionaries that themselves contain other dictionaries or lists. (Remember how we could nest lists in other lists? This is similar!)\nHere’s an example showing how we might store information about the TP53 gene:\n\n# Gene information database\n#\n# Imagine there are more genes in here too....\ngene_database = {\n    \"TP53\": {\n        \"full_name\": \"Tumor Protein P53\",\n        \"chromosome\": \"17\",\n        \"position\": {\"start\": 7_571_720, \"end\": 7_590_868},\n        \"aliases\": [\"p53\", \"TRP53\"],\n    }\n}\nprint(gene_database)\n\n{'TP53': {'full_name': 'Tumor Protein P53', 'chromosome': '17', 'position': {'start': 7571720, 'end': 7590868}, 'aliases': ['p53', 'TRP53']}}\n\n\nLet’s use the filing cabinet metaphor again: the main drawer is labeled “TP53”, and inside that drawer are several folders containing different types of information. Some of these folders (like “position”) contain their own sub-folders! (Alright, it’s not the greatest metaphor…but hopefully you get the idea!)\nLet’s break down what we’re storing:\n\nBasic information: The full name and chromosome location\nPosition data: Both start and end coordinates on the chromosome\nAlternative names: A list of other common names for the gene\n\nTo access this information, we use square brackets to “drill down” through the layers. Each set of brackets takes us one level deeper:\n\n# Get the full name\ngene_name = gene_database[\"TP53\"][\"full_name\"]\nprint(gene_name)\n\n# Get the start position\nstart_position = gene_database[\"TP53\"][\"position\"][\"start\"]\nprint(start_position)\n\n# Get the first alias\nfirst_alias = gene_database[\"TP53\"][\"aliases\"][0]\nprint(first_alias)\n\nTumor Protein P53\n7571720\np53\n\n\nIt’s pretty similar to nested lists, right?\n\nHandling Missing Data in Nested Dictionaries\nWith nested dictionaries, accessing missing data requires extra care to avoid errors. Let’s see why:\n\n# Trying to access data that doesn't exist\ntry:\n    # Attempting to access methylation data that isn't stored\n    methylation = gene_database[\"TP53\"][\"methylation\"][\"site\"]\nexcept KeyError as error:\n    print(f\"Oops! That data isn't available: {error}\")\n\nOops! That data isn't available: 'methylation'\n\n\nThis code will raise a KeyError because we’re trying to access a key (“methylation”) that doesn’t exist. When dealing with nested structures, it’s particularly important to handle these cases because an error could occur at any level of nesting.\nHere is what happens if we try and access a key that doesn’t exist in the position map:\n\ntry:\n    middle_position = gene_database[\"TP53\"][\"position\"][\"middle\"]\nexcept KeyError as error:\n    print(f\"Oops! That data isn't available: {error}\")\n\nOops! That data isn't available: 'middle'\n\n\nAs you see, this approach will work for missing keys at different levels of nesting.\nOne thing to be aware of if you are mixing lists and dictionaries is that while “drilling down” into the data structure you could potentially get errors other than KeyError:\n\ntry:\n    an_alias = gene_database[\"TP53\"][\"aliases\"][10]\nexcept IndexError as error:\n    print(f\"Oops! That data isn't available: {error}\")\n\nOops! That data isn't available: list index out of range\n\n\nIn this case, we need to handle the IndexError because the data that the aliases key points to is a list, but that list doesn’t have enough items to handle our request for the item at index 10. Don’t worry too much right now on handling specific errors. We will discuss error handling in greater depth in a future tutorial.\nWhile there are quite a few other ways to handle missing data when “drilling down” through nested data structures in Python, for now, we will just use the try/except approach similar to the one shown above.\n\n\n\nDefault Dictionaries: A Nice Way to Handle Missing Keys\nWe mentioned earlier that you should check for key presence in a dictionary before doing something interesting with that key to avoid key errors. Default dictionaries solve this problem elegantly by automatically creating new entries with preset values when you access a key that doesn’t exist yet.\nA default dictionary is sort of like a self-initializing storage system. Instead of having to check if a key exists before using it, the dictionary takes care of that for you. It’s particularly useful when you’re counting occurrences or building categorized lists.\nYou can create default dictionaries with three common starting values:\n\nint: starts new entries at zero (perfect for counting)\nlist: starts new entries with an empty list [] (great for categorizing or grouping)\nstr: starts new entries with an empty string \"\"\n\nHere is an example showing how to initialize default dictionaries:\n\nfrom collections import defaultdict\n\n# For counting things (starts at 0)\nnucleotide_counts = defaultdict(int)\n\n# For grouping things (starts with empty list)\ngenes_chromosomes = defaultdict(list)\n\nLet’s look at some practical examples.\n\nCounting Items with defaultdict\nSay we want to count nucleotides in a DNA sequence. It is pretty straightforward with a default dictionary:\n\nnucleotide_counts = defaultdict(int)\ndna_sequence = \"ATGCATTAG\"\n\nfor base in dna_sequence:\n    nucleotide_counts[base] += 1\n\nfor nucleotide, count in nucleotide_counts.items():\n    print(f\"{nucleotide} =&gt; {count}\")\n\nA =&gt; 3\nT =&gt; 3\nG =&gt; 2\nC =&gt; 1\n\n\nWhat’s happening here? Each time we see a nucleotide:\n\nIf we haven’t seen it before, defaultdict automatically creates a counter starting at 0\nWe add 1 to the counter\n\nWithout defaultdict, we’d need this more complicated code:\n\nnucleotide_counts = {}\ndna_sequence = \"ATGCATTAG\"\n\nfor base in dna_sequence:\n    if base in nucleotide_counts:\n        nucleotide_counts[base] += 1\n    else:\n        nucleotide_counts[base] = 1\n\nfor nucleotide, count in nucleotide_counts.items():\n    print(f\"{nucleotide} =&gt; {count}\")\n\nA =&gt; 3\nT =&gt; 3\nG =&gt; 2\nC =&gt; 1\n\n\nYuck!\n\n\nGrouping Items with defaultdict\nDefault dictionaries are also great for grouping related items. Let’s organize some genes by their chromosomes:\n\nchromosomes = defaultdict(list)\n\nchromosomes[\"chr17\"].append(\"TP53\")\nchromosomes[\"chr13\"].append(\"BRCA2\")\nchromosomes[\"chr17\"].append(\"BRCA1\")\n\nfor chromosome, genes in chromosomes.items():\n    for gene in genes:\n        print(f\"{chromosome}, {gene}\")\n\nchr17, TP53\nchr17, BRCA1\nchr13, BRCA2\n\n\nNotice how we didn’t need to create empty lists for each chromosome first? The defaultdict does it for us. Each time we reference a new chromosome, it automatically creates an empty list ready to store genes.\n\n\ndefaultdict Summary\nThe default dictionary approach is particularly useful when you’re:\n\nCounting frequencies of any kind\nGrouping items by categories\nBuilding collections of related items\n\nDefault dictionaries combine the power of regular dictionaries with automatic handling of new keys, making your code both simpler and more robust.\n\n\n\nCounters\nPython has another type of dictionary called a counter. Counters provide a convenient way to tally hashable items.\nLet’s return to our example from above, but this time, we will use a Counter.\n\nfrom collections import Counter\n\n# This is all you need to tally the nucleotides!\nnucleotide_counts = Counter(\"ATGCATTAG\")\n\n# You can loop through the Counter like a dictionary\nfor nucleotide, count in nucleotide_counts.items():\n    print(f\"{nucleotide} =&gt; {count}\")\n\nA =&gt; 3\nT =&gt; 3\nG =&gt; 2\nC =&gt; 1\n\n\nWe can find the N most common items using most_common:\n\nprint(nucleotide_counts.most_common(2))\n\n[('A', 3), ('T', 3)]\n\n\nVery nice!\nWhat if we wanted to calculate the ratio of nucleotides rather than the raw counts? A counter can help us here too:\n\nnucleotide_counts = Counter(\"ATGCATTAG\")\n\ntotal = nucleotide_counts.total()\n\nfor nucleotide, count in nucleotide_counts.items():\n    ratio = count / total\n    print(f\"{nucleotide} =&gt; {ratio:.3f}\")\n\nA =&gt; 0.333\nT =&gt; 0.333\nG =&gt; 0.222\nC =&gt; 0.111\n\n\nPretty cool, right?\nCounters have lots of other neat methods and operator support that you may want to check out and use in your own programs.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "chapters/02_collections.html#control-flow-with-collections",
    "href": "chapters/02_collections.html#control-flow-with-collections",
    "title": "2  Collections",
    "section": "Control Flow with Collections",
    "text": "Control Flow with Collections\nNow that we have covered some of Python’s data structures and collections, and gone over the different type of loops, let’s dive a little deeper into how you can combine collections, loops, and control flow into more realistic programs.\n\nOverview\nYou have already seen how to loop over collections and sequences. But it never hurts to have a few more examples. Here is the for loop on a couple of different type of sequences:\n\nphrase = \"Hello, Python!\"\nfor letter in phrase:\n    print(letter)\n\nfoods = [\"apple\", \"pie\", \"grape\", \"cookie\"]\nfor food in foods:\n    print(food)\n\nfor number in range(2, 10, 2):\n    print(number)\n\nprices = {\"book\": 19.99, \"pencil\": 0.55}\n\n# By default, we only get the keys of a dictionary\n# in the for loop\nfor item in prices:\n    print(item)\n\n# Use .items() to get the key and value\nfor item, price in prices.items():\n    print(f\"{item} =&gt; ${price}\")\n\n# Use .values() to get just the values\nfor price in prices.values():\n    print(price)\n\nH\ne\nl\nl\no\n,\n \nP\ny\nt\nh\no\nn\n!\napple\npie\ngrape\ncookie\n2\n4\n6\n8\nbook\npencil\nbook =&gt; $19.99\npencil =&gt; $0.55\n19.99\n0.55\n\n\nAs we mentioned earlier, you can use the for loop on anything that is iterable.\nRecall that if you want to get the position of the item in the sequence over which you are looping, use enumerate.\n\nphrase = \"Hello, Python!\"\nfor index, letter in enumerate(phrase):\n    print(f\"{index}: {letter}\")\n\nfoods = [\"apple\", \"pie\", \"grape\", \"cookie\"]\nfor index, food in enumerate(foods):\n    print(f\"{index}: {food}\")\n\nfor index, number in enumerate(range(2, 10, 2)):\n    print(f\"{index}: {number}\")\n\n0: H\n1: e\n2: l\n3: l\n4: o\n5: ,\n6:  \n7: P\n8: y\n9: t\n10: h\n11: o\n12: n\n13: !\n0: apple\n1: pie\n2: grape\n3: cookie\n0: 2\n1: 4\n2: 6\n3: 8\n\n\nYou can use enumerate with dictionaries as well, but it is a bit less common, as many times when you are using a dictionary you don’t really care about the order anyway.\n\n\nControlling the Flow of Loops\nWhen you’re working with loops, sometimes you need more than just going through items one by one. You might want to skip certain items, stop the loop early, or take different actions based on what you find. Let’s explore some techniques that will give you more control over how your loops behave.\n\nMaking Decisions in Loops\nWe can use boolean expressions and conditional statements to make decisions inside of loops. This allows us to take different actions depending on characteristics of the data.\n\nfor n in range(10):\n    if n &gt; 5:\n        print(n)\n\n6\n7\n8\n9\n\n\nHere, we are looping through the numbers from 0 to 9, and if the number is 6 or more, then we print it, otherwise, we just go on to the next number.\nIn this example, we want to keep DNA sequences that start with the start codon ATG:\n\nstart_codon = \"ATG\"\nsequences = ['ATGCGC', 'AATTAA', 'GCGCGC', 'TATATA']\n\nwith_start_codons = []\n\nfor sequence in sequences:\n    if sequence.startswith(start_codon):\n        with_start_codons.append(sequence)\n\nprint(with_start_codons)\n\n['ATGCGC']\n\n\nThis example is actually a decent one for a comprehension:\n\nstart_codon = \"ATG\"\nsequences = ['ATGCGC', 'AATTAA', 'GCGCGC', 'TATATA']\n\nwith_start_codons = [\n    sequence for sequence in sequences if sequence.startswith(start_codon)\n]\n\nprint(with_start_codons)\n\n['ATGCGC']\n\n\nComprehensions can be nice for simple filtering and transformations, like in this example. However, you should be cautious about making them too complex. As a rule of thumb:\nGood for comprehensions:\n\nSimple filters (like checking if something starts with “ATG”)\nBasic transformations (like converting strings to uppercase)\nWhen the logic fits naturally on one line\n\nAvoid comprehensions when:\n\nThe logic gets nested or complicated\nMultiple operations are involved\nThe line becomes hard to read at a glance\n\nIn this case, the comprehension is kind of nice because it’s doing a single, straightforward filter operation. But remember: code readability is more important than being clever. If you find yourself writing a complex comprehension, consider using a regular for loop instead.\n\n\nbreak\nSometimes you find what you’re looking for before going through the entire sequence. The break statement is like having an “early exit” button – it lets you stop the loop immediately when certain conditions are met. Sometimes this can make your code more efficient by preventing unnecessary iterations.\nIn this example, we are interested in seeing if a collection of DNA sequences contains at least one sequence with an ambiguous base (N), and if so, save that DNA fragment and stop looking:\n\nsequences = ['ATGCGC', 'AATTAGA', 'GCNGCGC', 'TCATATA']\n\nfor i, sequence in enumerate(sequences):\n    print(f\"checking sequence {i+1}\")\n    # Recall that we can use `in` to check if a\n    # letter is in a word.\n    if \"N\" in sequence:\n        print(f\"sequence {i+1} had an N!\\n\")\n        sequence_with_n = sequence\n        break\n\nprint(sequence_with_n)\n\nchecking sequence 1\nchecking sequence 2\nchecking sequence 3\nsequence 3 had an N!\n\nGCNGCGC\n\n\nNotice how the loop stops after the 3rd sequence and doesn’t continue all the way until the end. This is thanks to the break keyword.\n\n\ncontinue\nThink of continue as a “skip to the next item” command. When you hit a continue statement, the loop immediately jumps to the next iteration. This is perfect for when you want to skip over certain items without stopping the entire loop, like focusing only on the data points that meet your criteria.\nIn this example, we only want to process protein fragments that start with Methionine (M) and skip the others. While there are multiple ways to approach this, let’s use continue:\n\nproteins = [\"MVQIPQNPL\", \"ILVDGSSYLYR\", \"MAYHAFPPLTNSA\", \"GEPTGA\"]\n\nfor protein in proteins:\n    if not protein.startswith(\"M\"):\n        continue\n\n    print(f\"we will process {protein}\")\n\nwe will process MVQIPQNPL\nwe will process MAYHAFPPLTNSA\n\n\nThis example is a little bit contrived. I actually think writing it without the continue is clearer:\n\nproteins = [\"MVQIPQNPL\", \"ILVDGSSYLYR\", \"MAYHAFPPLTNSA\", \"GEPTGA\"]\n\nfor protein in proteins:\n    if protein.startswith(\"M\"):\n        print(f\"we will process {protein}\")\n\nwe will process MVQIPQNPL\nwe will process MAYHAFPPLTNSA\n\n\n\n\n\nA Practical Example: Simulating Bacterial Growth\nLet’s look at something more interesting – simulating how bacteria might grow over time. We’ll create a simple model where each bacterium can grow, shrink, or stay the same size each day.\nPay particular attention to this exmaple. It will be useful for Miniproject 1!\n\nimport random\n\ntotal_bacteria = 15\n\n# Make 15 bacteria all starting with size 10\nbacteria = [10] * total_bacteria\n\n# Simple \"growth\" rules:\n#\n# - 50% chance to grow\n# - 25% chance to shrink\n# - 25% chance to stay the same\n\n# The outer loop tracks days in the experiment\nfor day in range(20):\n\n    # The inner loop tracks each individual bateria\n    for i in range(total_bacteria):\n        chance = random.random()\n\n        # First we check if this bacterium will grow today\n        if chance &lt; 0.5:\n            bacteria[i] += 1\n        # If it will not grow, we need to check if it will shrink\n        elif chance &lt; 0.75:\n            bacteria[i] -= 1\n\n        # We don't need the `else` here because if the bacterium\n        # won't grow AND it won't shrink, then no action is required.\n\n# Finally, we print out the sizes of all the bacteria\n# at the end of the experiment\nfor id, size in enumerate(bacteria):\n    print(f\"bacterium {id+1}, size: {size}\")\n\nbacterium 1, size: 14\nbacterium 2, size: 14\nbacterium 3, size: 16\nbacterium 4, size: 16\nbacterium 5, size: 11\nbacterium 6, size: 17\nbacterium 7, size: 18\nbacterium 8, size: 18\nbacterium 9, size: 18\nbacterium 10, size: 15\nbacterium 11, size: 9\nbacterium 12, size: 14\nbacterium 13, size: 11\nbacterium 14, size: 13\nbacterium 15, size: 13\n\n\nHere is what is happening:\n\nIn the outer loop, we run the simulation for 20 days, with each iteration representing one day of bacterial growth.\nIn the inner loop, we check each bacterium in our population and apply the growth rules using random chances.\nThen we loop through the bacteria sizes and print out the final size of each bacterium. (We treat the bacterium’s location in the array (plus one) as its ID.)\n\n\nHow the Random Choices Work\nThe clever part here is how we use a single random number to make weighted choices. Think of it like a number line from 0 to 1, divided into three sections:\n┌────────────────────┬──────────┬──────────┐\n│ 50%                │ 25%      │ 25%      │\n└────────────────────┴──────────┴──────────┘\n↑                    ↑          ↑          ↑\n0.0                  0.5        0.75       1.0\nWhen we generate a random number between 0 and 1:\n\nIf it falls in the first half (0.0-0.5), the bacterium grows\nIf it falls in the next quarter (0.5-0.75), the bacterium shrinks\nIf it falls in the last quarter (0.75-1.0), the bacterium stays the same size\n\nThis is one way to implement different probabilities for different outcomes. While this example uses bacterial growth, you could adapt this pattern for any situation where you need to simulate random events with different probabilities – like mutation rates, drug responses, or population changes.\nIf you are curious, Python has a method that simplifies this random choice logic. Check it out if you’re curious! You might want to use it for your first miniproject….",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "chapters/02_collections.html#common-sequence-operations",
    "href": "chapters/02_collections.html#common-sequence-operations",
    "title": "2  Collections",
    "section": "Common Sequence Operations",
    "text": "Common Sequence Operations\nYou may have noticed that we can treat many of Python’s collection types in a similar way.\nOne of Python’s most helpful features is that many collection types (like lists, strings, and tuples) share the same basic operations. This means once you learn how to work with one type of sequence, you can apply that knowledge to others – you can find the length of any sequence using len(), check if something exists in a sequence using in, or grab a specific element using square bracket notation [].\nFor instance, whether you’re working with a DNA sequence as a string or a list of gene names, you can use the same syntax: len(\"ATCG\") and len([\"nrdA\", \"nrdJ\"]) both work the same way!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "chapters/02_collections.html#choosing-the-right-collection",
    "href": "chapters/02_collections.html#choosing-the-right-collection",
    "title": "2  Collections",
    "section": "Choosing the Right Collection",
    "text": "Choosing the Right Collection\nWhen deciding which type of collection to use, consider these three key questions:\n\n“How will I create or receive this data initially?”\n“How will I need to access this data later?”\n“How will I need to modify this data?”\n\nHere’s a practical guide to help you choose:\n\nUse a list when…\n\nYour data has a meaningful order (e.g., lines from a file, time series)\nYou need to access items by position (index) or slices\nYou need ordered operations (iteration in sequence, sorting, reversing)\nYou want efficient operations at the end of the collection (append/pop)\nYou need to maintain duplicates\nYou need to modify items in place\n\n\n\nUse a dictionary when…\n\nYour data naturally comes as key-value pairs\nYou need to look up values by a unique identifier (key)\nYou need to efficiently find, add, or update specific items without linear searching\nYou want to map one piece of data to another\nYou need to combine data from multiple sources using a common key\n\n\n\nUse a set when…\n\nYou only care about uniqueness, not order or association\nYou need automatic elimination of duplicates\nYou’re only concerned with presence/absence of items\nYou need to perform set operations (unions, intersections, differences)\nYou need fast membership testing\n\n\n\nExamples\nFor instance, when processing a FASTA file, you’ll encounter ID-sequence pairs. If you need to access sequences by their identifiers later, a dictionary is the natural choice. However, if you’re only interested in the sequences themselves and won’t need to reference them by ID, storing just the sequences in a list would be more appropriate.\nAs another example, consider analyzing homology search results where you need to organize multiple hits that correspond to each query sequence. If you’ll need to retrieve all hits for a specific query using its identifier, a dictionary is ideal. You could structure it with query IDs as keys and lists of corresponding hits as values, allowing efficient lookup of results for any particular query of interest:\n\n# Tuples of query-target-bitscore -- imagine these come directly from a BLAST\n# output file or something similar.\nhomology_search_results = [\n    (\"query_1\", \"target_1\", 95),\n    (\"query_1\", \"target_2\", 32),\n    (\"query_2\", \"target_1\", 112)\n]\n\nquery_hits = {}\n\nfor query, target, bitscore in homology_search_results:\n    hit_info = (target, bitscore)\n\n    if query in query_hits:\n        query_hits[query].append(hit_info)\n    else:\n        query_hits[query] = [hit_info]\n\nprint(query_hits[\"query_2\"])\n\n[('target_1', 112)]\n\n\n\n\nSummary\nTo summarize, select the collection type that both enhances code readability and aligns with your specific patterns of data creation, access, and modification throughout your program’s workflow.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "chapters/02_collections.html#key-takeaways",
    "href": "chapters/02_collections.html#key-takeaways",
    "title": "2  Collections",
    "section": "Key Takeaways",
    "text": "Key Takeaways\nWe’ve covered a lot of material about some of Python’s most commonly used data structures. Here are some key takeaways.\n\nGeneral Suggestions\n\nGenerally keep data types consistent within collections\nUse clear, descriptive names\nChoose the simplest structure that works\nUse list comprehensions for simple transformations\nHandle missing dictionary keys with get\nConsider memory usage with large datasets\n\n\n\nWatch Out For\n\nModifying lists while iterating\nForgetting tuple immutability\nMissing dictionary keys\nInfinite loops\nUsing lists when dictionaries would be more appropriate",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Collections</span>"
    ]
  },
  {
    "objectID": "chapters/03_algorithms.html",
    "href": "chapters/03_algorithms.html",
    "title": "3  Algorithmic Thinking",
    "section": "",
    "text": "Overview\nAn algorithm is a step-by-step procedure for solving a problem or accomplishing a task. It as a detailed set of instructions that takes some input, follows a clear sequence of steps, and produces a desired output.\nAlgorithms can vary greatly in their level of complexity, from simple operations like finding the larger of two numbers to complex tasks such as generating a phylogenetic tree from a sequence alignment. It’s worth noting that the same problem might have multiple algorithmic solutions, each with its own advantages and trade-offs in terms of simplicity and efficiency.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algorithmic Thinking</span>"
    ]
  },
  {
    "objectID": "chapters/03_algorithms.html#overview",
    "href": "chapters/03_algorithms.html#overview",
    "title": "3  Algorithmic Thinking",
    "section": "",
    "text": "Key Characteristics of Algorithms\n(Adapted from The Art of Computer Programming by Donald E. Knuth)\nAll algorithms share some important properties:\n\nDefined inputs & outputs\n\nAlgorithms must have clearly defined inputs and outputs.\nExample: PCR protocol\n\nInput: Template DNA, primers, nucleotides, polymerase\nOutput: Amplified DNA fragments\n\n\nDefiniteness\n\nSteps must be clear and unambiguous\nEach step must be understood exactly the same way by anyone following it\nExamples:\n\nGood example: “Heat the sample at 95°C for 5 minutes”\nBad example: “Heat the sample for a while”\n\n\nFiniteness\n\nThe algorithm must terminate after a finite number of steps\nI.e., it cannot run indefinitely\nExamples:\n\nGood example: A PCR reaction has a specific number of cycles\nBad example: “Keep checking gel until bands appear” (no clear end point)\n\n\nEffectiveness\n\nEach step must be basic enough to be executed\nMust be doable with available resources (ideally by a person using a pen and paper, but not always practical)\nExamples:\n\nGood example: “Pipette 100 µL”\nBad example: “Separate molecules instantly”\n\n\n\nThere are a few more important properties of algorithms. Generally an algorithm should produce the same output given the same input. For example, if your algorithm is supposed to triple a number, an input of 5 should always produce an output of 15. Additionally, an algorithm should ideally be general enough to solve similar problems in a category. Your tripling algorithm would be more useful (and general) if a user could supply both the number to be multiplied (multiplicand) and the multiplier. This way, the same algorithm could be used for doubling, tripling, quadrupling, etc.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algorithmic Thinking</span>"
    ]
  },
  {
    "objectID": "chapters/03_algorithms.html#algorithmic-thinking-process",
    "href": "chapters/03_algorithms.html#algorithmic-thinking-process",
    "title": "3  Algorithmic Thinking",
    "section": "Algorithmic Thinking Process",
    "text": "Algorithmic Thinking Process\nBeing able to think algorithmically is essential for success in programming. Algorithmic thinking is the ability to break down problems into clear, logical steps that a computer can follow – like writing a very detailed recipe where nothing can be assumed or left to interpretation. This skill helps you break down complex problems and translate them into effective code solutions.\nLet’s go through the various aspects of algorithms.\n\nBasic Components\nEvery algorithm consists of three fundamental parts:\n\nInput\n\nThe data or information that your algorithm needs to work with.\nThis could be numbers, text, DNA sequences, or any other form of data.\n\nProcessing\n\nThe step-by-step instructions that transform your input into the desired result.\nThis is essentially your recipe or procedure.\n\nOutput\n\nThe final result or solution that your algorithm produces.\nThis should match what you need to solve your problem.\n\n\nBefore you can write an algorithm, you need to understand what problem you’re trying to solve:\n\nDefining the problem scope\n\nClearly state what your algorithm should and shouldn’t do.\nFor example, “Find all prime numbers under 100” is clearer than “Find prime numbers.”\n\nUnderstanding requirements\n\nList everything your solution needs to handle.\nWhat kinds of input should it work with?\nWhat should it do with invalid input?\n\n\nYou can think of these as “behind-the-scenes” components. They are critical to algorithmic thinking and construction, but not always explicitly part of the algorithm itself.\n\n\nBreaking Problems Into Steps\nOnce you have these components in mind, you can break large problems into smaller pieces, which are much more manageable:\n\nOne big problem -&gt; Mutliple sub-problems\n\nBreak your main problem into smaller, manageable tasks.\nInstead of “Analyze DNA sequence,” think about\n\nRead sequence\nCheck validity\nFind patterns\n\nThese steps can get as granular as necessary for you to solve the problem at hand.\n\nDetermine the essential operations needed for each sub-problem.\nCreate a logical sequence of operations\n\nArrange your sub-problems in a logical order.\nWhat needs to happen first?\nWhich steps depend on other steps?\n\n\n\n\nPseudocode Development\nDepending on the complexity of your problem, it can be helpful to sketch out your solution in plain language or pseudocode:\n\nWriting abstract steps\n\nWrite out your algorithm in everyday language.\nUse simple statements like “For each number in the list” or “If sequence is valid then…”\n\nPlanning program flow\n\nMap out how your program will move from start to finish.\nWhat decisions need to be made?\nWhat steps might need to repeat?\n\nOutlining solution structure\n\nOrganize your steps into a clear structure, showing where loops and decisions occur.\n\n\nPlanning your code’s structure and components before diving into actual programming makes the whole process much smoother. When you tackle problems this way, you can focus on one aspect at a time, first mapping out the logic and flow, then implementing the code itself. This approach prevents you from getting overwhelmed by trying to solve multiple challenges simultaneously.\nWhile thorough planning is essential when you’re learning, you’ll likely develop a more streamlined approach as you gain experience. For simpler problems, you may find yourself able to start coding directly, having internalized the planning process. However, for complex projects, taking time to sketch out your approach first remains valuable regardless of your skill level.\n\n\nImplementation\nNow that you have a solid plan, it’s time to translate it into working code.\n\nConvert each step from your pseudocode into actual Python code, one piece at a time\nBuild your code following the structure you mapped out earlier\nKeep your code clean and maintainable by:\n\nUsing descriptive variable names that make sense\nAdding helpful comments to explain what your code does\nFollowing consistent formatting and organization\n\n\nThis stage is a bit like assembling the pieces of a puzzle where you already know what the final picture should look like. Take your time with each component – rushing through implementation often leads to mistakes that can be challenging to fix later.\n\n\nTesting and Validation\nAfter your implementation is complete, be sure to test that your algorithm works correctly:\n\nTesting with simple examples\n\nStart with basic test cases where you know the correct answer.\nCheck that your algorithm produces correct results for all expected inputs.\n\nIterative refinement\n\nImprove your solution based on test results.\nFix errors and handle edge cases.\n\n\nWe will discuss more testing strategies in a later tutorial.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algorithmic Thinking</span>"
    ]
  },
  {
    "objectID": "chapters/03_algorithms.html#real-world-algorithm-example-making-coffee",
    "href": "chapters/03_algorithms.html#real-world-algorithm-example-making-coffee",
    "title": "3  Algorithmic Thinking",
    "section": "Real-World Algorithm Example – Making Coffee",
    "text": "Real-World Algorithm Example – Making Coffee\nLet’s take an everyday activity, making coffee, and practice turning it into clear instructions that could work as an algorithm. We will start with some pretty bad instructions, identify problems with them, and then refine them.\n(Apologies to all the tea lovers reading this!)\n\nTake 1\nHere is a silly set of instructions for making coffee:\n\nYou’ll want to put some liquid in there first, then put the paper thing in. Get the coffee ready – not too much, not too little. Make sure everything is closed tight before you get things going. Now, just give it a tap and wait a while. If all goes well, you should end up with something drinkable!\n\nIf you have ever made coffee before, you could probably figure out how to follow these instructions. However, it doesn’t really work as an algorithm:\n\n“liquid”: should I add water or milk?\n“in there”: in where?\n“paper thing” instead of filter\n“coffee”: should I add coffee beans, ground coffee, instant coffee?\n“give it a tap” instead of pressing the start button\n“not too much, not too little”: no specific measurements or timing\nUses subjective phrases like “nice and tight” and “you know how it goes”\nUncertain outcome (“if all goes well”)\n\nLet’s address some of these issues and try again.\n\n\nTake 2\n\nPour fresh water into the top part until it looks full enough. Insert a clean paper filter (any size should work) into the basket area. Measure some coffee grounds – about a few spoonfuls should do it, depending on how strong you like it. Make sure to close the top properly until you hear a click or something. Find the power button (it might be on the front or side) and push it down. After a few minutes when you stop hearing the machine make noise, your coffee should be done!\n\nThough this version is definitely better than the last one, it still has a few issues:\n\nImprecise measurements (“looks full enough”, “a few spoonfuls”)\nAmbiguous specifications (“any size should work”)\nSubjective criteria (“how strong you like it”)\nUncertain timing (“a few minutes”)\nVague sensory cues (“hear a click or something”, “stop hearing the machine”)\nOptional or unclear elements (“or something”, “might be on the front”)\n\nAgain, if you have ever used a coffee machine, you could probably understand the instructions and adapt them to your taste to make a good cup of coffee. But to be a good algorithm, it still needs more precision, less ambiguity, and it shouldn’t leave so much up to your own taste.\nLet’s address some more of those ambiguities.\n\n\nTake 3\n\nPour 8 cups of fresh water into the top reservoir, filling to the marked water line. Insert a #4 cone paper filter into the filter basket. Measure 2 level tablespoons of ground coffee per cup of water (16 tablespoons total for a full pot). Press down firmly on the lid until you hear a distinct click indicating it’s fully closed. Locate the power switch on the front panel and press it to the “ON” position. The brewing process will take approximately 5-7 minutes, and is complete when the gurgling sound stops and the brewing indicator light turns off. Your coffee is now ready to serve.\n\nHere are some specific improvements as compared to the last version:\n\nUsing specific measurements (8 cups, #4 filter, 2 tablespoons per cup)\nProviding clear indicators (marked water line, distinct click)\nGiving a defined time range (5-7 minutes)\nIncluding concrete completion signals (gurgling stops, indicator light)\nSpecifying exact locations (front panel)\n\n\n\nBeyond the Basic Steps\nThough we could keep refining these instructions, it’s not a bad description of making coffee now!\nIf this were a “real algorithm” that we needed to program in Python, there are some more things we should think about. When writing instructions for a computer (or a coffee maker!), it’s easy to focus on the happy path – the sequence of actions that work perfectly. However, robust algorithms must consider various other factors to effectively handle real-world situations where things can go wrong.\nHere are some things to think about that are “beyond the basic steps”.\n\nSetup and Requirements\nBefore starting any process, we need to ensure everything is in place. This includes checking equipment, materials, and the system’s readiness. (You might see the term “preconditions” if you are reading about algorithms online.)\n\nGeneral Questions:\n\nHave we verified all equipment is functional?\nAre all necessary materials available?\nIs the system in a ready state?\n\nCoffee Maker Example:\n\nIs the coffee maker plugged in and working?\nIs it clean/ready to use?\nDo you have all needed supplies on hand?\n\n\n\n\nHandling Problems\nThings can go wrong. A good algorithm anticipates potential problems and provides solutions.\n\nGeneral Questions:\n\nHow do we handle insufficient resources?\nWhat happens if components fail?\nHow do we respond to interruptions?\nWhat backup procedures are needed?\n\nCoffee Maker Example:\n\nWhat if there’s not enough water?\nWhat if the filter is inserted incorrectly?\nWhat if the machine doesn’t turn on?\nWhat if the brewing stops midway?\n\n\nWhile you can’t generally anticipate everything that may go wrong, it’s a good idea to put some thought into it, and try to handle any likely errors.\n\n\nSequential Dependencies\nGenerally, certain steps will rely on others. We need to define the correct order of operations.\n\nGeneral Questions:\n\nWhich steps must happen in a specific order?\nWhat are the critical timing requirements?\nWhich steps block others from proceeding?\n\nCoffee Maker Example:\n\nThe filter must be inserted before adding coffee grounds\nWater must be added before turning on the machine\nThe lid must be closed before powering on\n\n\n\n\nConditional Pathways\nAlgorithms often need to handle different scenarios based on input or conditions.\n\nGeneral Questions:\n\nHow do varying inputs affect the process?\nWhat alternative routes exist?\nHow do we handle different scenarios?\n\nCoffee Maker Example:\n\nIf making less than a full pot, adjust measurements accordingly\nIf using different grind sizes, adjust portions\n\n\n\n\nValidation\nValidation and verification of any post-conditions is essential to ensure each step is completed successfully and the final result is correct.\n\nGeneral Questions:\n\nHow do we verify each step succeeded?\nWhat indicates proper operation?\nHow do we confirm the final result?\n\nCoffee Maker Example:\n\nHow to check if the filter is seated properly\nHow to verify the water is actually flowing/brewing\nHow to confirm the coffee is properly brewed\n\n\n\n\nSummary\nWhile we don’t need this level of detail for every example, it’s valuable to understand how simple procedures evolve into robust algorithms through careful consideration of edge cases, error handling, and validation steps.\nThis methodology applies broadly to software development: start simple, then systematically address complexities and potential problems.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algorithmic Thinking</span>"
    ]
  },
  {
    "objectID": "chapters/03_algorithms.html#building-blocks-for-solving-programming-problems",
    "href": "chapters/03_algorithms.html#building-blocks-for-solving-programming-problems",
    "title": "3  Algorithmic Thinking",
    "section": "Building Blocks for Solving Programming Problems",
    "text": "Building Blocks for Solving Programming Problems\nWhen you’re learning to program, it helps to recognize that many solutions are built from common, reusable patterns. These patterns are basic building blocks that you can combine and adapt to solve more complex problems.\nWhile there are often many ways to solve a programming challenge, we’ll focus on straightforward approaches that are easy to understand and implement. These might not always be the most efficient solutions, but they’re good learning tools that will help you:\n\nBreak big problems into manageable pieces\nLearn reliable approaches to common challenges\nDevelop your problem-solving skills\n\nAs you gain experience, you’ll learn more sophisticated methods, or ways that are built-in to the language itself, but mastering these fundamental patterns first will give you a solid foundation. Let’s look at some practical examples that demonstrate these basic patterns in action.\nIn this tutorial, we will mostly focus on strategies that involve looking at one element at a time from a sequence. Often, this sequential processing will also involve tracking or accumulating values.\n\nCharacter Processing\nTutorial 2 showed many examples of using for loops to process characters of a string one-by-one. We will repeat some of them here so that you can get more practice seeing the common patterns.\n\nPrinting Each Character\nPrinting each letter of a string:\n\nword = \"HELLO\"\nfor character in word:\n    # Do something interesting with each character...\n    print(character)\n\nH\nE\nL\nL\nO\n\n\n\n\nIterating with an Index\nAccessing the index of the character during iteration:\n\n# Print with position\nword = \"hello\"\nfor index, letter in enumerate(word):\n    print(f\"Position {index}: {letter}\")\n\nPosition 0: h\nPosition 1: e\nPosition 2: l\nPosition 3: l\nPosition 4: o\n\n\n\n\nIterating in Reverse\nProcessing a string in reverse order:\n\n# Process in reverse\nfor letter in reversed(word):\n    print(letter)\n\no\nl\nl\ne\nh\n\n\n\n\nFrequencies\nCounting the frequency of individual letters:\n\nletter_counts = {}\n\nfor letter in word:\n    current_count = letter_counts.get(letter, 0)\n    letter_counts[letter] = current_count + 1\n\nprint(letter_counts)\n\n{'h': 1, 'e': 1, 'l': 2, 'o': 1}\n\n\nNote: This is a good example of what I mentioned above regarding these solutions not always being the best way to do something. In Tutorial 2, we discussed a better way to approach this particular counting problem. Can you remember it?\n\n\n\nNumber Processing\n\nRunning Sum\nTracking a running sum:\n\nnumbers = [2, 5, 3, 1]\ntotal = 0\n\nfor number in numbers:\n    total += number\n\nprint(f\"Total: {total}\")\n\nTotal: 11\n\n\nWhile Python provides built-in functions like sum() for this specific case, understanding the basic pattern helps with more complex variations.\n\n\nSumming Positive Numbers\nSum of positive numbers:\n\nnumbers = [-1, 2, -5, 3, -8, 1]\n\npositive_sum = sum(num for num in numbers if num &gt; 0)\n\nprint(f\"Sum of positive numbers: {positive_sum}\")\n\nSum of positive numbers: 6\n\n\n\n\nAverages\nCalculating the average of a list of numbers:\n\n# Calculate average\nnumbers = [2, 5, 3, 8, 1]\naverage = sum(numbers) / len(numbers)\nprint(f\"Average: {average}\")\n\nAverage: 3.8\n\n\n\n\n\nFinding Maximum/Minimum\nFinding the largest number in a list without using Python’s built-in max function:\n\nnumbers = [5, 3, 0, -1, 8]\nlargest_number = numbers[0]\n\nfor number in numbers[1:]:\n    if number &gt; largest_number:\n        largest_number = number\n\nprint(largest_number)\n\n8\n\n\nFinding the shortest string in a list:\n\nwords = [\"i\", \"like\", \"apple\", \"pie\"]\nshortest_word = words[0]\n\nfor word in words[1:]:\n    if len(word) &lt; len(shortest_word):\n        shortest_word = word\n\nprint(shortest_word)\n\ni\n\n\n\n\nSimple Search/Validation\nAnother common task is finding an item in a collection or validating some condition of a collection.\n\nFinding a Number in a List\nFinding a specific number in a list:\n\ntarget = 5\nnumbers = list(range(10))\nis_found = False\n\nfor number in numbers:\n    if number == target:\n        is_found = True\n        print(\"we found the number!\")\n\nif not is_found:\n    print(\"we didn't find the number!\")\n\nwe found the number!\n\n\n\n\nIs a List Sorted?\nChecking if a list is sorted. (Before reading the code, try and think of how the solution might look.)\n\nnumbers = [1, 2, 4, 3, 5]\nprevious_number = numbers[0]\n\nis_sorted = True\n\nfor current_number in numbers[1:]:\n    if current_number &lt; previous_number:\n        is_sorted = False\n        break\n    previous_number = current_number\n\nif is_sorted:\n    print(\"the list is sorted!\")\nelse:\n    print(\"the list is not sorted!\")\n\nthe list is not sorted!\n\n\nThis example has a couple of interesting things to focus on:\n\nWe start the iteration at index 1 in the array\nAs soon as we see a number that is not sorted, we break since that is enough to say the array as a whole is unsorted.\n\n\n\n\nNested Loops\nProblems often require nested loops, such as cases where for every item in one list, you need to process every item in another list. Note that these nested loop problems can often be solved in clever ways that help you avoid a having to look at every combination. There’s a good chance you will see some of these clever solutions as you are exposed to more code in the future.\n\nDistance Between Points\nCalculating distances between points. Here we are using 1-dimensional points. The distance between two points in 1D (on a line) is the absolute value of their difference. E.g., if you have two points x₁ and x₂, the distance between them is |x₁ - x₂|.\n\npoints = [8, 3, 4]\ndistances = []\n\nfor x in points:\n    for y in points:\n        distance = abs(x - y)\n        distances.append((x, y, distance))\n\nfor x, y, distance in distances:\n    print(f\"({x}, {y}) =&gt; {distance}\")\n\n(8, 8) =&gt; 0\n(8, 3) =&gt; 5\n(8, 4) =&gt; 4\n(3, 8) =&gt; 5\n(3, 3) =&gt; 0\n(3, 4) =&gt; 1\n(4, 8) =&gt; 4\n(4, 3) =&gt; 1\n(4, 4) =&gt; 0\n\n\nYou could imagine instead of distances of 1D points, this pattern could work for calculating all-vs-all homology scores from BLAST output, or comparing some aspect of each sample vs. every other sample.\n\n\nDistance Between Samples\nHere’s a slightly different example. In this case, say we have ecological distances between all sampling locations stored in a dictionary. Here is one way that you might loop through them:\n\nsample_distances = {\n    \"S1\": {\"S1\": 0, \"S2\": 3, \"S3\": 5},\n    \"S2\": {\"S1\": 2, \"S2\": 0, \"S3\": 1},\n    \"S3\": {\"S1\": 6, \"S2\": 2, \"S3\": 0},\n}\n\nfor sample_a, other_samples in sample_distances.items():\n    for sample_b, distance in other_samples.items():\n        print(f\"{sample_a} -&gt; {sample_b} =&gt; {distance}\")\n\nS1 -&gt; S1 =&gt; 0\nS1 -&gt; S2 =&gt; 3\nS1 -&gt; S3 =&gt; 5\nS2 -&gt; S1 =&gt; 2\nS2 -&gt; S2 =&gt; 0\nS2 -&gt; S3 =&gt; 1\nS3 -&gt; S1 =&gt; 6\nS3 -&gt; S2 =&gt; 2\nS3 -&gt; S3 =&gt; 0\n\n\nWhile there are often clever ways to avoid these type of all-vs-all comparisons, they still come up pretty frequently, so it’s a good idea to get familiar with them!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algorithmic Thinking</span>"
    ]
  },
  {
    "objectID": "chapters/03_algorithms.html#introduction-to-algorithm-analysis",
    "href": "chapters/03_algorithms.html#introduction-to-algorithm-analysis",
    "title": "3  Algorithmic Thinking",
    "section": "Introduction to Algorithm Analysis",
    "text": "Introduction to Algorithm Analysis\nWhen we write code to solve a problem, there’s usually more than one way to do it. It’s a bit like how you may have different routes to get to work – some are faster, some are more efficient, and some are just easier to remember. The same applies to our code solutions.\nWhen evaluating different approaches to solving a problem, we typically look at three main things:\n\nDoes it actually solve the problem correctly?\nHow efficiently does it run (in terms of time and computer memory)?\nIs it clear and maintainable?\n\n\nTime Complexity\nLet’s focus on efficiency in terms of time for a moment. Imagine you have a list of genes to search through. You could check each gene one by one (we call this linear time), or you might have a clever way to eliminate half the possibilities with each step (logarithmic time). As your gene list grows from hundreds to millions of entries, these different approaches can mean the difference between waiting seconds versus hours for your results.\nComputer scientists use something called “Big O notation” to describe how an algorithm’s performance changes as the input gets larger. Here are some common patterns you’ll encounter.\n\nConstant time (O(1)): The operation always takes the same amount of time\nLinear time (O(n)): The time increases directly with the size of the input\nQuadratic time (O(n²)): The time increases with the square of the input size\n\nThe key takeaway is that some solutions scale better than others when working with larger datasets. As you write code, keeping these basic patterns in mind will help you make better choices about how to approach problems.\nHere are some simple examples to illustrate these three time complexities.\n\nConstant Time – O(1)\nConstant time operations like dictionary lookups:\n\ngene_info = {\"nrdA\": \"ribonucleotide reductase\"}\nresult = gene_info[\"nrdA\"]\nprint(result)\n\nribonucleotide reductase\n\n\n\n\nLinear Time – O(n)\nLinear time operations like checking each item in a list once:\n\n# Counting mutations\ndna_sequence = \"ACTACTGTACTACTGTCACACTAGAGTAT\"\nt_count = 0\n\nfor base in dna_sequence:\n    if base == \"T\":\n        t_count += 1\n\nprint(t_count)\n\n9\n\n\n\n\nQuadratic Time – O(n²)\nQuadratic time operations like comparing every item with every other item:\n\n# Finding equivalent sequences\nsequences = [\"ACTG\", \"ATGAC\", \"ACTGGT\", \"ACTG\"]\nsequence_count = len(sequences)\n\nfor i in range(sequence_count):\n    for j in range(sequence_count):\n        if i != j and sequences[i] == sequences[j]:\n            print(f\"Match found: {sequences[i]}\")\n\nMatch found: ACTG\nMatch found: ACTG\n\n\n\n\n\nSpace Complexity\nIn addition to thinking about how long our code takes to run, sometimes we also need to consider how much memory it uses. Space complexity describes how memory usage grows with input size. The two most common patterns you’ll encounter are:\n\nO(1) space: Uses a fixed amount of extra memory regardless of input size\nO(n) space: Uses extra memory that grows with the input size\n\nHere are some examples.\n\nConstant Space – O(1)\nIn a constant space solution, the same few variables are used regardless of the input size:\n\ng_count = 0\n\nfor base in dna_sequence:\n    if base == \"G\":\n        g_count += 1\n\nprint(g_count)\n\n4\n\n\nIn this example, we’re just counting, so we only need one variable no matter how long the DNA sequence is.\n\n\nLinear Space – O(n)\nIn a linear space solution, the space needed to calculate the result grows linearly with the size of the input.\n\ng_positions = []\n\nfor i in range(len(dna_sequence)):\n    if dna_sequence[i] == \"G\":\n        g_positions.append(i)\n\nprint(g_positions)\n\n[6, 14, 23, 25]\n\n\nIn this example, we’re storing positions, so we need more space for longer sequences.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algorithmic Thinking</span>"
    ]
  },
  {
    "objectID": "chapters/03_algorithms.html#algorithmic-puzzles",
    "href": "chapters/03_algorithms.html#algorithmic-puzzles",
    "title": "3  Algorithmic Thinking",
    "section": "Algorithmic Puzzles",
    "text": "Algorithmic Puzzles\nLet’s finish off this tutorial by looking at a common, beginner-level algorithmic puzzle: checking if a string is a palindrome.\n\nA word is a palindrome if it reads the same forward and backward.\n\nNote: This problem description is adapted from LeetCode problem 125. Valid Palindrome.\n\nStarting with the Problem\nFirst, let’s understand what we’re trying to do in plain English:\n\nWe need to check if a word reads the same forwards and backwards\nExamples\n\n“racecar” → Yes!\n“hello” → No!\n\n\n(For this version of the problem, we can assume that the strings we need to check are all a single word with all lowercase letters.)\n\n\nSolution 1: The Obvious Way\nLet’s start with the most obvious solution that uses Python string slicing to check the definition of a palindrome.\n\nstring = \"racecar\"\nis_palindrome = string == string[::-1]\nprint(string, is_palindrome)\n\nstring = \"apple\"\nis_palindrome = string == string[::-1]\nprint(string, is_palindrome)\n\nracecar True\napple False\n\n\nThis is probably how most people would first think about it: “Just reverse it and compare!”\n\nIt’s perfectly valid\nIt’s easy to understand\nIt uses built-in Python functions\nBut…It requires creating a whole new reversed string in memory\n\nOften, the “but” doesn’t really matter in whatever work you are doing. Many times “clear and maintainable” are much more important that optimal efficiency. However, in the world of algorithmic puzzles, the “but” is definitely something you want to address!\n\n\nSolution 2: Manual Comparison with a Loop\nFor this solution, we think, “Wait, do we really need to reverse the string? What a waste of time and space!”\nInstead, we will look at “pairs” of letters. First, let’s try a word that is a palindrome:\n\nstring = \"racecar\"\nprint(\"Checking {string}\")\nis_palindrome = True\n\nfor i in range(len(string)):\n    j = len(string) - i - 1\n\n    print(i, j, string[i], string[j])\n\n    if string[i] != string[j]:\n        is_palindrome = False\n        break\n\nprint(string, is_palindrome)\n\nChecking {string}\n0 6 r r\n1 5 a a\n2 4 c c\n3 3 e e\n4 2 c c\n5 1 a a\n6 0 r r\nracecar True\n\n\nNext, try a word that is not a palindrome, just to see the difference:\n\nstring = \"racethecar\"\nprint(\"\\n\\nChecking {string}\")\nis_palindrome = True\n\nfor i in range(len(string)):\n    j = len(string) - i - 1\n\n    print(i, j, string[i], string[j])\n\n    if string[i] != string[j]:\n        is_palindrome = False\n        break\n\nprint(string, is_palindrome)\n\n\n\nChecking {string}\n0 9 r r\n1 8 a a\n2 7 c c\n3 6 e e\n4 5 t h\nracethecar False\n\n\nDo you see how the non-palindrome stops before checking all the values?\nHere is a breakdown of the above solution:\n\nWe compare the first letter with last letter\nThen, the second letter with second-to-last letter\nAnd so on…\nBut…We’re doing each comparison twice!\n\nJust so it is clear, let’s explain that j index line. This diagram shows why we use that formula to calculate j:\nlen(\"racecar\") == 7\n\n┌───┬───┬───┬───┬───┬───┬───┐\n│ r │ a │ c │ e │ c │ a │ r │\n└───┴───┴───┴───┴───┴───┴───┘\n  0   1   2   3   4   5   6\n  ↑   ↑   ↑   ↑   ↑   ↑   ↑\n  i=0 │   │   │   │   │   j = 7 - 0 - 1 = 6\n      │   │   │   │   │\n      i=1 │   │   │   j = 7 - 1 - 1 = 5\n          │   │   │\n          i=2 │   j = 7 - 2 - 1 = 4\n              │\n              i=3, j = 7 - 3 - 1 = 3\n\nand so on...\n\n\nSolution 3: The Optimized Version\nThere was another “but” in Solution 2: Wouldn’t it be better if we didn’t have to do those duplicated checks? Let’s give it a shot.\n\nstring = \"racecar\"\nis_palindrome = True\n\ni = 0\nj = len(string) - 1\n\nwhile i &lt; j:\n    print(i, j, string[i], string[j])\n\n    if string[i] != string[j]:\n        is_palindrome = False\n        break\n\n    i += 1\n    j -= 1\n\nprint(string, is_palindrome)\n\n0 6 r r\n1 5 a a\n2 4 c c\nracecar True\n\n\nAnd here again with a string that is not a palindrome:\n\nstring = \"racethecar\"\nis_palindrome = True\n\ni = 0\nj = len(string) - 1\n\nwhile i &lt; j:\n    print(i, j, string[i], string[j])\n\n    if string[i] != string[j]:\n        is_palindrome = False\n        break\n\n    i += 1\n    j -= 1\n\nprint(string, is_palindrome)\n\n0 9 r r\n1 8 a a\n2 7 c c\n3 6 e e\n4 5 t h\nracethecar False\n\n\nAnd the breakdown:\n\nWe use two “pointers” moving toward each other\nWe only check each pair once\nWe stop at the middle\n\nThis is both time and space efficient, and doesn’t do any more checks than we need to do. Cool, right?\n\n\nGeneral Approach\nThe above process of refinement suggests a general approach to these kinds of algorithmic puzzles.\n\nStart simple\n\nImplement the first solution that comes to mind\nDon’t worry if it’s not perfect\nMake sure it works!\n\nQuestion your approach\n\nDo I need all these steps?\nAm I repeating work?\nIs there a more direct way?\n\nLook for patterns\n\nNotice we’re comparing pairs of letters\nNotice we’re moving inward from both ends\nThese observations lead to better solutions\n\nConsider resource usage\n\nTime: How many steps are we taking?\nSpace: How much extra memory do we need?\nCan we reduce either?\n\n\nFocus on making a basic version work before aiming for perfection. Begin with a simple solution, ensure it functions correctly, and then gradually improve it. This mirrors the process of algorithmic thinking described above of breaking down complex problems into manageable steps and refining your solution as needs evolve. This is similar to how programming works in real-world scenarios!",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algorithmic Thinking</span>"
    ]
  },
  {
    "objectID": "chapters/03_algorithms.html#summary-connection-to-bioinformatics",
    "href": "chapters/03_algorithms.html#summary-connection-to-bioinformatics",
    "title": "3  Algorithmic Thinking",
    "section": "Summary & Connection to Bioinformatics",
    "text": "Summary & Connection to Bioinformatics\nIn this tutorial, we introduced the concept of algorithmic thinking and simple algorithms. We went over some common patterns for simple problems that can form the building blocks of more complex solutions. Then we covered the basics of algorithmic complexity analysis, and finally, went through the process of solving a common algorithmic puzzle.\nYou might be wondering how these basic programming concepts connect to the bioinformatics tools you’ll use in your research. While we rely on sophisticated software for tasks like homology search and genome assembly, these powerful tools are built on the same fundamental programming principles we’re learning now.\nAlgorithmic thinking, or understanding how to break down problems and translate them into logical steps, is a foundational skill for all coding work. Though we won’t be building complex bioinformatics tools from scratch in this course, mastering the basics will give you a solid foundation for writing your own analysis scripts and understanding how the bioinformatics tools you use actually work.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algorithmic Thinking</span>"
    ]
  },
  {
    "objectID": "chapters/03_algorithms.html#bibliography",
    "href": "chapters/03_algorithms.html#bibliography",
    "title": "3  Algorithmic Thinking",
    "section": "Bibliography",
    "text": "Bibliography\nKnuth, Donald E. 1997. The Art of Computer Programming: Volume 1: Fundamental Algorithms. 3rd ed. Boston, MA: Addison Wesley.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Algorithmic Thinking</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions.html",
    "href": "chapters/04_functions.html",
    "title": "4  Functions",
    "section": "",
    "text": "Introduction\nUntil now, we’ve mostly been using built-in Python’s functions like print(), len(), and range() to get things done. While Python’s standard library provides a ton of useful functionality, eventually you will need to create something more tailored to your specific needs.\nThis is where custom functions come in. Functions are like reusable blocks of code that you design to perform specific tasks. Creating your own functions allows you to extend Python’s capabilities beyond what’s available “out of the box.” In this module, we’ll explore functions from the ground up: their purpose, how to create them, and how to write them effectively.\nLearning to work with functions is a core programming skill that offers several key benefits:\nWhether you’re analyzing data sets, automating repetitive tasks, or building scientific applications, functions will become an essential part of your programming toolkit. Let’s dive in and learn how to create them!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions.html#introduction",
    "href": "chapters/04_functions.html#introduction",
    "title": "4  Functions",
    "section": "",
    "text": "It helps you tackle large problems by breaking them into smaller, manageable parts\nIt makes your code more organized and easier to follow\nIt makes your code easier for others to understand and use\nIt eliminates the need to copy and paste code repeatedly\nIt reduces mistakes by creating tested, reliable code blocks you can reuse\n\n\n\nWhat is a Function?\nA function is a reusable block of code that performs a specific task, a sort of standard procedure for performing a particular computation or task in your code.\nFunctions help us organize our code by breaking down complex problems into smaller, more manageable pieces. For example, instead of writing one massive program that does everything, we can create separate functions for each logical step. This makes our code easier to write, understand, and fix when something goes wrong.\nOne important feature of functions is that we can give them descriptive names that explain what they do. When you see a function named calculate_average or find_peak_values, you immediately have a good idea of its purpose. This makes your code more readable and easier to maintain.\nYou might hear functions called by different names like methods, procedures, or subroutines, depending on the programming language or context. Don’t worry too much about these different terms; for now, we will simply call them functions. Regardless of their name, their main purpose remains the same: to package up a set of instructions that we can easily reuse.\nLet’s start with something familiar - mathematical functions. You might remember seeing expressions like \\(f(x) = 2x\\) in math class. This simple function takes any number \\(x\\) and doubles it. Graphically, it creates a straight line where each input \\(x\\) corresponds to an output \\(y\\) that’s twice as large:\n  y\n\n6 │        •\n  │       /\n  │      /\n4 │     •\n  │    /\n  │   /\n1 │  •\n  └─────────── x\n     1  2  3\nWe can create a function with similar behavior in Python:\n\ndef times_2(x):\n    return 2 * x\n\nHere we see a function called times_2 that takes a value x and returns a value that is twice as large (2 * x). Let’s use the seaborn package to visualize some inputs and outputs of the times_2 function:\n\n# Import the seaborn package\nimport seaborn as sns\n\n\n# Create some x values\nxs = [1, 2, 3]\n\n# The y values are results of running\n# the function on all the x values\nys = [times_2(x) for x in xs]\n\n# Print out the y values\nprint(ys)\n\n# Finally, draw a plot of the results.\nsns.relplot(ys, kind=\"line\", aspect=0.5)\n\n[2, 4, 6]\n\n\n\n\n\n\n\n\n\nAt its core, a function is like a machine that follows a specific set of instructions:\n          ┌─────┐\ninput ──► │  ✦  │ ──► output\n          └─────┘\na function ──┘\nYou put something in (input), the function processes it according to its instructions, and you get something out (output).\nAs we will see, Python functions are more flexible than mathematical ones. They can:\n\nTake multiple inputs (or none at all)\nReturn collections of values (or nothing at all)\nPerform actions beyond just calculations (like printing text or saving files)\n\n\n\nWhy Do We Need Functions?\nYou can think of Python functions as pre-packaged units of code that perform specific tasks. When you write a function, you’re creating a reusable tool that you can call whenever you need it. Functions create a logical boundary around related operations, giving them a clear purpose and identity, which can make code more readable, reusable, and maintainable. Here’s a simple example that shows how functions make code more readable:\ngene_expression_data = read_csv(\"gene_expression.csv\")\n\nupregulated_genes = find_upregulated_genes(gene_expression_data)\n\nplot_expression_data(upregulated_genes)\nEven if you don’t know exactly how these functions work internally, you can probably guess what this code does just by reading the function names. When you combine descriptive function names with clear variable names, your code becomes self-documenting, that is, it will be easier to understand without additional comments or explanations.\nHere are some of the advantages and benefits of using functions in programming:\n\nAbstraction\n\nFunctions hide complex operations behind simple, easy-to-use interfaces\nYou can use a function without needing to understand all the details of how it works internally\n\nOrganization\n\nFunctions help break down complex problems into smaller, manageable pieces\nA well-organized series of function calls is much easier to understand than a long block of detailed code\n\nReusability\n\nOnce you write a function, you can use it again in similar contexts\nFunctions can be shared across different projects\nThis saves time and reduces the chance of errors from rewriting the same code\n\nTestability\n\nFunctions make it easier to test your code in small, isolated pieces\nYou can verify each function works correctly on its own\nIf individual functions work properly, you can more confidently combine them into larger programs\n\n\nFunctions are the building blocks of your programs. Each block performs a specific task, and when you combine them thoughtfully, you can create complex programs that solve real-world problems. The key is to make each function clear and focused – if you can understand what each piece does on its own, it becomes much easier to work with them as a whole.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions.html#function-syntax",
    "href": "chapters/04_functions.html#function-syntax",
    "title": "4  Functions",
    "section": "Function Syntax",
    "text": "Function Syntax\nNow that we understand the basic concept of functions, let’s look at how to write them in Python. In a sense, you will need to learn the grammar of writing functions in Python.\nHere’s a simple example that checks if a DNA sequence ends with certain stop codons:\n\ndef ends_with_stop_codon(dna_sequence, stop_codons):\n    \"\"\"Check if the given DNA sequence ends with any of the given stop codons.\"\"\"\n    result = dna_sequence.endswith(stop_codons)\n    return result\n\n\nstop_codons = (\"TAA\", \"TAG\", \"TGA\")\nresult = ends_with_stop_codon(\"ATGAAACCACTGGTGGTTAA\", stop_codons)\nprint(result)\n\nTrue\n\n\nLet’s break down that down:\n\nFunction Definition\n\ndef ends_with_stop_codon(dna_sequence, stop_codons): ...\n\n\nThe def keyword tells Python you’re creating a new function\nends_with_stop_codon is the name you’re giving your function\nInside the parentheses are your parameters (dna_sequence and stop_codons)\nThe colon : marks where the function details begin\n\nRemember to use lowercase letters with underscores for function names (like read_csv, not readCSV).\n\n\nKey Function Components\n\nDocstring\n\nThe text between triple quotes \"\"\"...\"\"\"\nExplains what the function does\n\nFunction body\n\nAll the indented code below the function definition\n\nReturn statement\n\nreturn result\nSpecifies what the function sends back\n\nFunction call\n\nends_with_stop_codon(\"ATGAAACCACTGGTGGTTAA\", stop_codons)\nHow you actually use the function\n\n\n\n\nIndentation Matters\nPython uses indentation to know what code belongs to your function. Everything indented after the function definition is part of that function:\n\ndef hello(name, excitement):\n    \"\"\"Create a greeting message.\"\"\"\n    msg = f\"Hello, {name}\"\n\n    if excitement == \"intense\":\n        msg += \".\"\n    elif excitement == \"happy\":\n        msg += \"!!!\"\n    else:\n        msg += \"!\"\n\n    return msg",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions.html#sec-function-parameters",
    "href": "chapters/04_functions.html#sec-function-parameters",
    "title": "4  Functions",
    "section": "Function Parameters",
    "text": "Function Parameters\nThe most common way of getting data into functions is through function parameters, which hold the data your function needs to work with.\nA quick note about terminology you’ll encounter: You’ll hear people use both “parameters” and “arguments” when talking about functions, and while they’re often used interchangeably, in this tutorial we will make the following distinction:\n\nParameters are the names you list when you’re creating your function. They are the “placeholders” that tell the function what data to expect.\nArguments are the actual values you send to the function when you use it.\n\nFor example, in this function, a and b are the parameters of the add function, and 1 and 2 are arguments to the function when it is called:\n\ndef add(a, b):\n    return a + b\n\n\nadd(1, 2)\n\n3\n\n\nDon’t worry too much about mixing up these terms. The important thing is understanding that functions need a way to receive data, and parameters/arguments are how we do that.\nFunction parameters and arguments are very flexible in Python. Let’s see how we can define and use them.\n\nPositional parameters\nLet’s look at our add function again:\n\ndef add(a, b):\n    return a + b\n\nIn this function a and b are positional parameters. When we call this function, like add(1, 2), Python matches each argument to its parameter based on position – that’s why they’re called “positional parameters”: the first argument (1) goes with the first parameter (a), and the second argument (2) goes with the second parameter (b).\nThis is the most basic and common way to define parameters in Python functions.\n\n\nKeyword Arguments\nCheck out this function that “clamps” a number between an upper and lower bound:\n\ndef clamp(x, min, max):\n    \"Clamp a number between a minimum and a maximum\"\n    if x &lt; min:\n        return min\n    elif x &gt; max:\n        return max\n    else:\n        return x\n\n(For simplicity, we’ll assume users provide valid inputs where min is always less than max.)\nWhile this function works, it has some potential usability issues. When calling this function, it’s not immediately clear which argument goes where. For instance:\n\nShould we put min before max, or vice versa?\nShould the value we’re clamping (x) go first, last, or in the middle?\nLooking at a call like clamp(37, 45, 63), it’s not obvious which number represents what without checking the function definition.\n\nThis is where Python’s keyword arguments come to the rescue! Instead of relying on the order of arguments, we can explicitly label them:\n\nprint(clamp(10, min=25, max=75))\n\n25\n\n\nThe format is straightforward: keyword_arg=value. The real power of keyword arguments is their flexibility. You can use keywords for some arguments but not others, and arrange the arguments in the order that makes the most sense for your use case.\nHere are several valid ways to call the same function:\n\nprint(clamp(10, max=75, min=25))\nprint(clamp(max=75, min=25, x=10))\nprint(clamp(min=25, max=75, x=10))\n\n25\n25\n25\n\n\nAll these calls do exactly the same thing, but the labeled arguments make it clear what each value represents.\n\nRules for Using Keyword Arguments\nWhen using keyword arguments in Python, there are several important rules to follow. Let’s look at some common mistakes and how to avoid them.\nDon’t forget the required arguments:\n\ntry:\n    # Where is the number to clamp?\n    clamp(min=25, max=75)\nexcept TypeError as error:\n    print(error)\n\nclamp() missing 1 required positional argument: 'x'\n\n\nPut the positional arguments before the keyword arguments:\n# (If you try to run this, you will get a SyntaxError.)\n\n# The 10 needs to go first!\nclamp(min=25, max=75, 10)\nDon’t provide the same argument twice:\n\ntry:\n    # Here, we're trying to set 'min' twice\n    clamp(10, 75, min=25)\nexcept TypeError as error:\n    print(error)\n\nclamp() got multiple values for argument 'min'\n\n\nOnly use keyword arguments that the function expects:\n\ntry:\n    # 'number' isn't a parameter name in clamp()\n    clamp(number=10, min=25, max=75)\nexcept TypeError as error:\n    print(error)\n\nclamp() got an unexpected keyword argument 'number'\n\n\nEssentially, these rules exist to prevent ambiguity so that Python knows which arguments go with which parameters.\n\n\n\nDefault Argument Values\nWhen creating functions, you can set default values for their arguments. This means if you call your function without specifying all the arguments, Python will use these preset defaults instead. This essentially gives you a way to create optional functional parameters. Check it out:\n\ndef hello(who=\"World\"):\n    print(f\"Hello, {who}!\")\n\n\nhello(\"Delaware\")\nhello()\n\nHello, Delaware!\nHello, World!\n\n\nIn this case, if no argument is provided when calling hello, Python automatically uses “World” as the default value.\nYou can also use variables to set these default values:\n\nplace = \"World\"\n\n\ndef hello(who=place):\n    print(f\"Hello, {who}!\")\n\n\nhello(\"Delaware\")\nhello()\n\nHello, Delaware!\nHello, World!\n\n\nPython sets these default values when you first define the function, not when you call it. It will look at any variables available at that moment (what we call “in scope”) to determine the default value. If you’re using a variable as a default value, make sure it’s defined before you create your function. We’ll explore the concept of scope in more detail later in the tutorial.\n\nA Common Pitfall: Mutable Default Arguments\nLet’s look at a subtle but important quirk in Python functions that can catch you off guard. Consider this seemingly straightforward function:\n\ndef sneaky_append(number, numbers=[]):\n    numbers.append(number)\n    return numbers\n\nThis function looks like it should do something simple: take a number, add it to a list, and if no list is provided, start with an empty one. Sounds reasonable, right?\nLet’s see what happens when we run it multiple times:\n\nprint(sneaky_append(3))\nprint(sneaky_append(0))\nprint(sneaky_append(2))\n\n[3]\n[3, 0]\n[3, 0, 2]\n\n\nSurprise! Instead of getting three separate lists, each containing one number, we get a single list that keeps growing. What’s going on here?\nThe key is understanding when Python creates that empty list we used as a default argument. Python creates it once when the function is defined, not each time the function is called. This means all calls to the function are sharing the same list!\nHere’s a better way to write this function:\n\ndef cozy_append(number, numbers=None):\n    if numbers is None:\n        numbers = []\n\n    numbers.append(number)\n    return numbers\n\n\nprint(cozy_append(3))\nprint(cozy_append(0))\nprint(cozy_append(2))\n\n[3]\n[0]\n[2]\n\n\nIn this improved version, we use None as our default argument and create a new empty list inside the function each time it’s called. This gives us the behavior we actually wanted: a fresh, empty list for each function call when no list is provided.\nThe takeaway? Be very careful about using mutable objects (like lists, dictionaries, or sets) as default arguments. Instead, use None as your default and create your mutable object inside the function.\n\n\n\nCombining Keyword Arguments & Default Arguments\nKeyword arguments and default arguments look pretty similar. Let’s take a look at them in the same example.\nKeyword arguments can be combined with default arguments as well. Let’s turn the min and max of our clamp function to default arguments.\n\ndef clamp(x, min=25, max=75):\n    \"Clamp a number between a minimum and a maximum\"\n    if x &lt; min:\n        return min\n    elif x &gt; max:\n        return max\n    else:\n        return x\n\n\n# You can override just one default argument.\nprint(clamp(10, min=5))  # Uses the default max=75\n\n# All these calls do the same thing\n\n# Using keyword arguments for the default parameters\nprint(clamp(10, max=75, min=25))\n\n# Using all keyword arguments\nprint(clamp(max=75, min=25, x=10))\n\n# Different order, same result\nprint(clamp(min=25, max=75, x=10))\n\n10\n25\n25\n25\n\n\nThere are a few important points to understand here:\n\nDefault arguments (min=25, max=75 in the function definition) provide fallback values when those arguments aren’t specified in the function call.\nKeyword arguments (like min=5 in the function call) let you specify which parameter you’re passing a value to.\nEven required parameters (like x) can be passed using keyword syntax (x=10), though this isn’t required.\nWhen using keyword arguments, the order doesn’t matter as long as keyword arguments follow any positional arguments.\n\nThis flexibility can be useful when working with functions that have multiple parameters, as it can help make your code more readable and prevent mistakes from mixing up the order of arguments.\n\n\nFunctions That Can Take Any Number of Arguments\nSometimes you want to write a function that can handle different numbers of inputs. Python makes this possible with variable-length arguments. Let’s explore how this works.\n\nTaking Multiple Positional Arguments\nTo specify that a function takes a variable number of positional arguments, you use the *args syntax. The asterisk (*) tells Python to accept any number of arguments and pack them into a tuple. Sometimes you will see these called variadic arguments. Check it out:\n\ndef process_samples(*samples):\n    for sample in samples:\n        print(f\"Processing sample: {sample}\")\n\n\n# Works with any number of arguments\nprocess_samples(\"A1\")  # One sample\nprocess_samples(\"A1\", \"A2\", \"B1\", \"B2\")  # Three samples\n\nProcessing sample: A1\nProcessing sample: A1\nProcessing sample: A2\nProcessing sample: B1\nProcessing sample: B2\n\n\nYou can combine the variadic arguments with positional arguments, as long as the formally specified positional arguments come first:\n\ndef print_stuff(separator, *words):\n    msg = separator.join(words)\n    print(msg)\n\n\nprint_stuff(\", \", \"apple\", \"banana\", \"cherry\", \"domino's pizza\")\n\napple, banana, cherry, domino's pizza\n\n\nThe *words parameter tells Python to collect all remaining arguments into a tuple called words. Having to specify the separator first before all the words you want to print feels a bit awkward to me. We can improve this making separator a keyword argument that comes last:\n\ndef print_stuff(*words, separator):\n    msg = separator.join(words)\n    print(msg)\n\n\nprint_stuff(\"apple\", \"banana\", \"cherry\", \"domino's pizza\", separator=\", \")\n\napple, banana, cherry, domino's pizza\n\n\nWhen you have an argument that follows the variadic arguments, it must be used like a keyword argument. For example, this doesn’t work:\n\ntry:\n    print_stuff(\"apple\", \"banana\", \"cherry\", \"domino's pizza\", \", \")\nexcept TypeError as error:\n    print(error)\n\nprint_stuff() missing 1 required keyword-only argument: 'separator'\n\n\nWithout using a keyword argument, Python has no way of knowing that the final argument you passed into the function shouldn’t be part of the words tuple.\nFinally, it is very common in these situations that a default argument be provided to the argument that comes after a variadic argument list:\n\ndef print_stuff(*words, separator=\", \"):\n    msg = separator.join(words)\n    print(msg)\n\n\nprint_stuff(\"apple\", \"banana\", \"cherry\", \"domino's pizza\")\n\napple, banana, cherry, domino's pizza\n\n\n\nCollections & Variadic Arguments\nHere’s something that might surprise you:\n\nfoods = [\"apple\", \"banana\", \"cherry\", \"domino's pizza\"]\n\ntry:\n    print_stuff(foods)\nexcept TypeError as error:\n    print(error)\n\nsequence item 0: expected str instance, list found\n\n\nWhen we pass a list directly, Python treats it as a single argument. To tell Python to treat each item in the list as a separate argument, we need to “unpack” the list using the * operator:\n\nfoods = [\"apple\", \"banana\", \"cherry\", \"domino's pizza\"]\nprint_stuff(*foods)  # This works!\n\napple, banana, cherry, domino's pizza\n\n\nLet’s look at another example that shows how this behavior can be tricky:\n\ndef greeter(*names):\n    for name in names:\n        print(f\"Hello, {name}!\")\n\n\n# This passes three separate arguments\ngreeter(\"Ryan\", \"Pikachu\", \"Shaq\")\n\n# This passes one argument (a list)\nprint()\ngreeter([\"Ryan\", \"Pikachu\", \"Shaq\"])\n\n# This \"unpacks\" the list again into multiple arguments\nprint()\ngreeter(*[\"Ryan\", \"Pikachu\", \"Shaq\"])\n\nHello, Ryan!\nHello, Pikachu!\nHello, Shaq!\n\nHello, ['Ryan', 'Pikachu', 'Shaq']!\n\nHello, Ryan!\nHello, Pikachu!\nHello, Shaq!\n\n\nCompare that to the version of greeter that takes a single collection argument rather than a variable number of arguments.\n\ndef greeter(names):\n    for name in names:\n        print(f\"Hello, {name}!\")\n\n\n# This passes three separate arguments\ntry:\n    greeter(\"Ryan\", \"Pikachu\", \"Shaq\")\nexcept TypeError as error:\n    print(error)\n\n# This passes one argument (a list)\nprint()\ngreeter([\"Ryan\", \"Pikachu\", \"Shaq\"])\n\n# This \"unpacks\" the list again into multiple arguments\nprint()\n\ntry:\n    greeter(*[\"Ryan\", \"Pikachu\", \"Shaq\"])\nexcept TypeError as error:\n    print(error)\n\ngreeter() takes 1 positional argument but 3 were given\n\nHello, Ryan!\nHello, Pikachu!\nHello, Shaq!\n\ngreeter() takes 1 positional argument but 3 were given\n\n\nAs you see, we had to wrap some of these in try/except blocks since they are using the function incorrectly.\n\n\n\nTaking Multiple Keyword Arguments\nTo specify that a function takes a variable number of keyword arguments, you use the **kwargs syntax. The double asterisk (**) tells Python to accept any number of arguments and pack them into a dictionary.\nLet’s look at an example that creates a simple product description:\n\ndef keyword_example(price, **keywords):\n    print(f\"the price is ${price}\")\n    for keyword, value in keywords.items():\n        print(f\"{keyword:&gt;8s} =&gt; {value}\")\n\n\nkeyword_example(\n    7.99,\n    fruit=\"apple\",\n    dessert=\"tart\",\n    taste=\"yum!\",\n    coolness=\"very\",\n)\n\nthe price is $7.99\n   fruit =&gt; apple\n dessert =&gt; tart\n   taste =&gt; yum!\ncoolness =&gt; very\n\n\nIn this function, price is a regular parameter that must be provided, while **keywords captures any additional keyword arguments as a dictionary. The function then prints each keyword and its value.\nWhen using **kwargs, it must be the last parameter in your function definition. If you try to put other parameters after it, Python will raise an error. (Try it yourself by swapping the order of price and **keywords to see what happens!) Contrast this with the variable length positional arguments, which could come before some keyword-only arguments.\nYou can also do the reverse: take a dictionary and “unpack” it into keyword arguments. Here’s an example:\n\ndef greeter(**greetings):\n    for greeting, people in greetings.items():\n        for person in people:\n            print(f\"{greeting} {person}\")\n\n\ngreeter(hello=[\"Ash\", \"Pikachu\"], goodbye=[\"Gary\", \"Eevee\"])\n\nprint()\n\ngreetings = {\"hello\": [\"Ash\", \"Pikachu\"], \"goodbye\": [\"Gary\", \"Eevee\"]}\ngreeter(**greetings)\n\nhello Ash\nhello Pikachu\ngoodbye Gary\ngoodbye Eevee\n\nhello Ash\nhello Pikachu\ngoodbye Gary\ngoodbye Eevee\n\n\nBoth calls to greeter() produce the same output, showing two different ways to pass keyword arguments to a function.\n\n\n\nCombining Variable-Length Arguments\nPython gives you the flexibility to combine regular parameters with variable-length arguments in the same function. Here’s how it works:\n\ndef example(a, b, *arguments, **keyword_arguments):\n    print(\"a:\", a)\n    print(\"b:\", b)\n    print(\"arguments:\", arguments)\n    print(\"keyword_arguments:\", keyword_arguments)\n\n\nexample(1, 2, 3, 4, 5, hello=\"world\", color=\"orange\")\n\na: 1\nb: 2\narguments: (3, 4, 5)\nkeyword_arguments: {'hello': 'world', 'color': 'orange'}\n\n\nIn this example:\n\na and b are regular parameters that must be provided\n*arguments collects any extra positional arguments (here: 3, 4, 5)\n**keyword_arguments collects any extra name=value pairs (here: hello=\"world\", color=\"orange\")\n\nYou’ll often see these written in a shorter form as *args and **kwargs in Python code:\n\ndef example(a, b, *args, **kwargs): ...\n\nThis is just a common convention - args stands for “arguments” and kwargs for “keyword arguments”. The important part is the * and ** symbols, not the names themselves.\nCheck out this guide, Python args and kwargs: Demystified, if you want to dive deeper into this topic.\n\n\nControlling How Arguments Are Passed\nWhen we call functions in Python, we can typically pass arguments in two ways: by their position in the parameter list or by explicitly naming them with keywords. However, Python also lets you set stricter rules about how arguments should be passed, requiring some to be positional-only or keyword-only. Here is how that looks:\n\ndef example(a, b, /, c, d, *, e, f): ...\n\nThis function’s parameters are divided into three groups:\n\nPositional-only parameters (before the /):\n\na and b must be passed by position\n\nStandard parameters (between / and *):\n\nc and d can be passed either by position or keyword\n\nKeyword-only parameters (after the *):\n\ne and f must be passed by keyword\n\n\nHere are some examples of valid and invalid ways to call the example function:\n\n# Valid calls\n\nexample(1, 2, 3, 4, e=5, f=6)\nexample(1, 2, c=3, d=4, e=5, f=6)\n\n# Invalid calls\n\ntry:\n    example(a=1, b=2, c=3, d=4, e=5, f=6)\nexcept TypeError as error:\n    print(error)\n\n\ntry:\n    example(1, 2, 3, 4, 5, 6)\nexcept TypeError as error:\n    print(error)\n\nexample() got some positional-only arguments passed as keyword arguments: 'a, b'\nexample() takes 4 positional arguments but 6 were given\n\n\nDon’t worry if this syntax seems tricky. While Python offers advanced parameter options, you won’t need them too much when learning. Focus on mastering basic positional and keyword arguments first, as these cover most programming needs. For more details on advanced features, check the Python documentation on special parameters.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions.html#return-values",
    "href": "chapters/04_functions.html#return-values",
    "title": "4  Functions",
    "section": "Return Values",
    "text": "Return Values\nEvery function in Python can give back (or “return”) a value when it finishes running. We use the return keyword to specify what value we want to get back:\nimport random\n\ndef random_number():\n    return random.random()\n\nprint(random_number())\nprint(random_number())\nLet’s explore some interesting ways we can use return statements.\n\nReturning Multiple Values\nSometimes we want a function to give back more than one piece of information. While Python doesn’t technically return multiple values at once, we can package multiple values into a tuple and return that instead:\n\ndef gc_count(dna_sequence):\n    g_count = dna_sequence.count(\"G\")\n    c_count = dna_sequence.count(\"C\")\n\n    return g_count, c_count\n\n\ndna_sequence = \"ACTGACTG\"\n\n# We can unpack the returned values into separate variables\ng_count, c_count = gc_count(dna_sequence)\nprint(g_count, c_count, sep=\", \")\n\n# Behind the scenes, Python is creating a tuple\nprint(type(gc_count(dna_sequence)))\n\n2, 2\n&lt;class 'tuple'&gt;\n\n\nThis is a convenient way to get multiple values out of a function. Python makes it easy to unpack these values into separate variables that we can use later in our code.\n\n\nFunctions With No Return Value\nWhat happens when a function doesn’t explicitly return anything? Check out this little function that just prints a greeting:\n\ndef say_hello(name):\n    msg = f\"Hello, {name}!\"\n    print(msg)\n\n\nsay_hello(\"Luka\")\n\nHello, Luka!\n\n\nWhen we don’t specify a return value, Python automatically returns a special value called None:\n\nresult = say_hello(\"LeBron\")\nprint(\"the result of `say_hello` is:\", result)\n\nHello, LeBron!\nthe result of `say_hello` is: None\n\n\nNone is Python’s way of representing “nothing” or “no value.” We can also explicitly return None when we want to indicate that a function couldn’t produce a meaningful result. Here’s an example:\n\ndef find_motif(dna_sequence, motif):\n    \"\"\"\n    Find the position of a motif in a DNA sequence.\n\n    Args:\n        dna_sequence (str): DNA sequence to search\n        motif (str): Motif to find\n\n    Returns:\n        position (int or None): Starting position of motif if found, None otherwise\n    \"\"\"\n    position = dna_sequence.find(motif)\n\n    if position == -1:\n        return None\n    else:\n        return position\n\n\nsequence = \"ATCGTATAGCAT\"\nprint(find_motif(sequence, \"TATA\"))\nprint(find_motif(sequence, \"GGGC\"))\n\n4\nNone\n\n\nIn this example, if we can’t find the motif, we return None to indicate that no result was found. This is a pretty common pattern. You’ll see it in built-in methods too, like the dictionary get() method:\n\nd = {\"a\": 1, \"b\": 2}\n\n# Tries to get a value that doesn't exist\nresult = d.get(\"c\")\n\nprint(result)\n\nNone\n\n\nNone is particularly useful when you need to indicate the absence of a value or when a function couldn’t complete its intended task successfully.\n\nAside: Early Returns & Conditional Expressions\nLet’s look at a few different ways to write the same function. We’ll use our motif-finding code as an example:\n\ndef find_motif(dna_sequence, motif):\n    position = dna_sequence.find(motif)\n\n    # Standard if/else\n    if position == -1:\n        return None\n    else:\n        return position\n\nWhile this standard if/else structure works perfectly well, you might encounter two other common patterns when reading Python code:\n\nEarly Return Pattern\nHere is the Early Return Pattern:\n\ndef find_motif_version_2(dna_sequence, motif):\n    position = dna_sequence.find(motif)\n\n    if position == -1:\n        # Exit the function early if no match is found\n        return None\n\n    # Otherwise return the position\n    return position\n\nIn this function, using the early return pattern doesn’t really make that much of a difference, because it is small. You could imagine a larger function that might have a few more checks leading to more nesting of conditional statements. In these cases, the early return pattern can really shine. Check out intentionally complicated example that takes some gene expression data and does some checks on it:\n\n# Without early returns =&gt; complex nesting and logic\ndef process_gene_data(gene_id, sequence, expression_level):\n    if gene_id is not None:\n        if sequence is not None:\n            if len(sequence) &gt;= 50:\n                if expression_level is not None:\n                    if expression_level &gt; 0:\n                        # Actually process the data\n                        processed_data = {\n                            \"id\": gene_id,\n                            \"sequence\": sequence,\n                            \"expression\": expression_level,\n                            \"normalized\": expression_level / 100,\n                        }\n                        return processed_data\n                    else:\n                        return {\"error\": \"Expression level must be positive\"}\n                else:\n                    return {\"error\": \"Missing expression level\"}\n            else:\n                return {\"error\": \"Sequence too short\"}\n        else:\n            return {\"error\": \"Missing sequence\"}\n    else:\n        return {\"error\": \"Missing gene ID\"}\n\nLet’s untangle that mess using the early return pattern:\n\ndef process_gene_data(gene_id, sequence, expression_level):\n    if gene_id is None:\n        return {\"error\": \"Missing gene ID\"}\n\n    if sequence is None:\n        return {\"error\": \"Missing sequence\"}\n\n    if len(sequence) &gt;= 50:\n        return {\"error\": \"Sequence too short\"}\n\n    if expression_level is None:\n        return {\"error\": \"Missing expression level\"}\n\n    if expression_level &lt;= 0:\n        return {\"error\": \"Expression level must be positive\"}\n\n    # At this point, we know the data is valid, so we can process it.\n    processed_data = {\n        \"id\": gene_id,\n        \"sequence\": sequence,\n        \"expression\": expression_level,\n        \"normalized\": expression_level / 100,\n    }\n\n    return processed_data\n\nAgain, this is an intentionally complex example to prove a point about early returns, but the point still stands: the second version is much less complex. It shows how early returns can:\n\nMake input validation clearer and more maintainable\nAvoid deeply nested conditional statements\nSeparate validation logic from the main processing\nMake it easier to add new validation steps later\n\n\n\nConditional Expressions\nThe other pattern is using a conditional expressions (also called a ternary operator) for the return value:\n\ndef find_motif_version_2(dna_sequence, motif):\n    position = dna_sequence.find(motif)\n\n    # Conditional expression\n    return None if position == -1 else position\n\nYou can also flip the condition around if it makes more sense for your specific case:\n\ndef find_motif_version_3(dna_sequence, motif):\n    position = dna_sequence.find(motif)\n\n    # Conditional expression with the check reversed\n    return position if position != -1 else None\n\n\n\nRecap\nAll these versions do exactly the same thing, but they express it in slightly different ways:\n\nThe standard if/else is the most verbose but also the most explicit\nThe early return pattern can make code more readable when you have multiple conditions to check\nThe conditional expression is more compact but might take some getting used to\n\nThere’s no “best” way – they’re all valid Python. However, it’s good practice to be consistent within a single script or project. In situations like these, it can often make sense to pick the style that makes the most sense to you and your colleagues and stick with it.\nCheck out PEP 308 for the full story behind Python’s conditional expressions.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions.html#sec-scope",
    "href": "chapters/04_functions.html#sec-scope",
    "title": "4  Functions",
    "section": "Scope & Name Resolution: Where Can You Use Your Variables?",
    "text": "Scope & Name Resolution: Where Can You Use Your Variables?\nScope is a set of rules that determine where you can use different names in your code (like variables, function names, etc.). Scope is essentially the “visibility” of variables in different parts of your code. Let’s look at a simple example to understand this better:\n\ndef some_genes():\n    # Create a list of genes inside the function\n    genes = [\"nrdA\", \"nrdJ\"]\n\n    # We can use `genes` here because we're inside the function\n    # where it was created\n    print(genes)\n\n\n# Let's try to access `genes` outside the function\ntry:\n    print(genes)\nexcept NameError as error:\n    print(error)\n\nname 'genes' is not defined\n\n\nIn this code, genes only exists inside the some_genes function. When we’re working inside that function, genes is “in scope”, meaning we can use it. However, as soon as we step outside the function, genes goes “out of scope”, and we can’t access it anymore.\nWhen does a name come into scope? In Python, this happens when you first create it, which can happen in several ways:\n\nAssigning a value to a variable (x = 1)\nImporting a module (import random)\nDefining a function (def add(): ...)\nCreating function parameters (def add(x, y): ...)\n\nNext, let’s look at how Python decides whether a name is in scope or not.\n\nUnderstanding Scope: How Python Finds Variables\nWhen you write code, Python needs to know where to look for the variables and functions you’re trying to use. It follows a specific search pattern called the LEGB Rule, which defines four levels of scope (think of scope as the “visibility” of variables in different parts of your code).\nLet’s break down these levels from smallest to largest:\n\nLocal Scope (L)\n\nThis is the most immediate scope, created whenever you define a function\nVariables created inside a function only exist inside that function\nEach time you call the function, Python creates a fresh local scope\n\nEnclosing Scope (E)\n\nThis comes into play when you have a function inside another function\nThe outer function’s scope becomes the “enclosing” scope for the inner function\nThe inner function can “see” and use variables from the outer function\nWe’ll explore this more when we discuss nested functions\n\nGlobal Scope (G)\n\nThese are variables defined in the main body of your script\nThey’re accessible throughout your program\n\nBuilt-in Scope (B)\n\nThis is Python’s pre-loaded toolkit\nIncludes all of Python’s built-in functions like print(), len(), and max()\nThese tools are always available, no matter where you are in your code\n\n\nWhen you use a variable name, Python searches through these scopes in order (L → E → G → B) until it finds a match. If it can’t find the name anywhere, you’ll get a NameError.\nLet’s go through each of these in more detail.\n\n\nLocal Scope: What Happens in a Function, Stays in a Function\nWhen we write functions, we create what’s called a “local scope”, which is sort of like the function’s private workspace. Any variables we create inside a function only exist inside that function. Once the function finishes running, these variables disappear, and we can’t access them from outside the function.\nImportant Note about Quarto and Jupyter Notebooks: In our notebook environment, code cells can see variables that were created in previous cells. For our examples to make sense, we need to start fresh. We’ll use a special notebook command called “reset” to clear out any existing variables.\n\n# This is a special notebook command that clears all our previous variables.\n# You won't use this in regular Python programs, it's just for notebooks.\n%reset -f\n\n\ndef example(x):\n    # Here, we can use 'x' because it's a parameter passed to our function\n    # We can also create new variables like 'y'\n    y = 10\n    print(x * y)\n\n\n# This works fine\nexample(2)\n\n# But watch what happens when we try to use these variables outside the\n# function.\n\ntry:\n    # This will be an error because 'x' doesn't exist out here\n    print(x)\nexcept NameError as error:\n    print(error)\n\ntry:\n    # Same problem with 'y': it only existed inside the function\n    print(y)\nexcept NameError as error:\n    print(error)\n\n20\nname 'x' is not defined\nname 'y' is not defined\n\n\nThis behavior is intentional! It helps keep our functions self-contained and prevents them from accidentally interfering with code outside the function. By default, functions can read variables from the global scope (outside the function), but they can’t modify them or create new global variables from inside the function.\n\n\nEnclosing Scope: Functions Within Functions\nSometimes we write functions inside other functions (nested functions). When we do this, the inner function has access to variables defined in the outer function. This relationship creates what we call an “enclosing scope.”\nLet’s look at an example:\n\n%reset -f\n\n\ndef outer():\n    # These variables are accessible throughout outer() and inner()\n    x = 1\n    y = 2\n\n    def inner():\n        # This creates a new 'y' that's different from the outer y\n        y = 10\n        print(f\"from inner -- x: {x}, y: {y}\")\n        return x + y\n\n    # Calculate z using inner()\n    z = inner()\n\n    print(f\"from outer -- x: {x}, y: {y}, z: {z}\")\n\n\nouter()\n\n# Once outer() finishes running, we can't access any of its variables\n# or the inner() function anymore:\n\ntry:\n    x\nexcept NameError as error:\n    print(f\"trying to access 'x' in global scope -- {error}\")\n\ntry:\n    y\nexcept NameError as error:\n    print(f\"trying to access 'y' in global scope -- {error}\")\n\ntry:\n    z\nexcept NameError as error:\n    print(f\"trying to access 'z' in global scope -- {error}\")\n\ntry:\n    inner()\nexcept NameError as error:\n    print(f\"trying to access 'inner' in global scope -- {error}\")\n\nfrom inner -- x: 1, y: 10\nfrom outer -- x: 1, y: 2, z: 11\ntrying to access 'x' in global scope -- name 'x' is not defined\ntrying to access 'y' in global scope -- name 'y' is not defined\ntrying to access 'z' in global scope -- name 'z' is not defined\ntrying to access 'inner' in global scope -- name 'inner' is not defined\n\n\nIn this example, inner() can “see” and use variables defined in outer() because outer() is its enclosing scope. Think of it like inner() being contained within outer()’s environment.\nA few key points:\n\nVariables defined in outer() are accessible inside inner()\nIf inner() creates a variable with the same name as one in outer(), the inner version takes precedence inside inner() (like y in our example)\nOnce outer() finishes running, none of its variables or the inner() function are accessible anymore\n\nThis concept of enclosing scope is useful when you want to create a function that needs access to variables from its surrounding context while keeping those variables private from the rest of your program.\n\n\nGlobal Scope: The World Is Your Variable\nNext up is global scope, which refers to variables that are defined at the top level of your Python script. While we’ll dive deeper into this when we cover modules, here’s what you need to know for now:\n\n%reset -f\n\nname = \"Pikachu\"\n\n\ndef say_hi():\n    print(f\"Hi, {name}!\")\n\n\nsay_hi()\n\nHi, Pikachu!\n\n\nIn this example, name is a global variable because it’s defined outside of any function. Functions can “see” and use global variables, which is why our say_hi() function can access name.\nHowever, there’s an important limitation: functions can’t modify global variables directly. Here’s what happens when we try:\n\n%reset -f\n\nbest_player = \"Messi\"\n\n\ndef update_best_player():\n    best_player = \"Ronaldo\"\n\n\nprint(best_player)\nupdate_best_player()\nprint(best_player)\n\nMessi\nMessi\n\n\nNotice that best_player stays as “Messi” even after we run the function. When we create best_player = \"Ronaldo\" inside the function, we’re actually creating a new, local variable that only exists inside the function. It doesn’t affect the global best_player.\nThere is a way to modify global variables from within a function using the global keyword, though it’s generally not recommended:\n\n%reset -f\n\nbest_player = \"Messi\"\n\n\ndef update_best_player():\n    # This tells Python we want to modify the global variable\n    global best_player\n    best_player = \"Ronaldo\"\n\n\nprint(best_player)\nupdate_best_player()\nprint(best_player)\n\nMessi\nRonaldo\n\n\nWhile using global works, it’s usually better to avoid it. Good programming practice encourage passing values as parameters and returning results from functions instead. This makes your code easier to understand and maintain.\n(There’s also a similar feature called nonlocal for nested functions, but that’s a topic for another day!)\n\nChanging Mutable Values from Within a Function\nLet’s look at how functions can modify certain types of data (like lists) that exist outside the function. This is a common pattern in Python, so it’s important to understand what’s happening.\n\nnumbers = [1, 2]\n\n\ndef append():\n    numbers.append(3)\n\n\nappend()\nprint(numbers)\nappend()\nprint(numbers)\n\n[1, 2, 3]\n[1, 2, 3, 3]\n\n\nThis works because lists in Python are mutable (changeable). Even though the list numbers is defined outside our function, we can still modify it from inside the function because Python is just following a reference to where that list lives in memory.\nHere’s another example that makes this concept more explicit:\n\ndef append_to(numbers, number):\n    print(f\"inside append_to, list id is {id(numbers)}\")\n    numbers.append(number)\n\n\nsome_numbers = [10, 11]\nprint(f\"list {id(some_numbers)}: {some_numbers}\")\n\nappend_to(some_numbers, 12)\nprint(f\"list {id(some_numbers)}: {some_numbers}\")\n\nappend_to(some_numbers, 13)\nprint(f\"list {id(some_numbers)}: {some_numbers}\")\n\nlist 4914683648: [10, 11]\ninside append_to, list id is 4914683648\nlist 4914683648: [10, 11, 12]\ninside append_to, list id is 4914683648\nlist 4914683648: [10, 11, 12, 13]\n\n\nIn this version, we’re being more explicit by passing the list as an argument to our function. The id() function shows us the memory address where our list lives. Notice how this ID stays the same throughout the program – that’s because we’re always working with the same list, just referring to it by different names (some_numbers outside the function and numbers inside it).\nThis behavior highlights an important aspect of how Python handles variables and mutable objects: variables are like name tags that point to data, rather than containers that hold data. When we pass a list to a function, we’re giving that function another name tag that points to the same data. We’ll revisit this topic again when we cover classes later in the course.\n\n\n\nBuilt-In Scope: Python’s Ready-to-Use Tools\nThink of Python’s built-in scope as your basic toolkit that’s always available when you start Python. These are the fundamental tools that Python automatically loads for you, and they’re the last place Python looks when trying to find where a name is defined (remember our LEGB rule).\nYou’ve already been using built-in functions throughout this course. For example:\n\ntotal = sum(range(6))\nprint(total)\n\n15\n\n\nThese functions like sum() and print() aren’t magic, they actually live in a specific place in Python called the builtins module, which contains essential tools like built-in functions, constants, and error types that you can use anywhere in your code.\nYou can see what’s available using Python’s special __builtins__ name:\n\n# Let's look at the first 10 built-in tools\nfor thing in dir(__builtins__)[0:10]:\n    print(thing)\n\nArithmeticError\nAssertionError\nAttributeError\nBaseException\nBaseExceptionGroup\nBlockingIOError\nBrokenPipeError\nBufferError\nBytesWarning\nChildProcessError\n\n\nWhile you normally don’t need to, you can also access these tools directly through the builtins module:\n\nimport builtins\n\ntotal = builtins.sum(builtins.range(6))\nbuiltins.print(total)\n\n%reset -f\n\n15\n\n\nThis explicit way of accessing built-ins isn’t common practice. It’s just helpful to understand where these tools actually live in Python’s structure.\n\n\nLEGB Recap\n┌─ BUILT-IN SCOPE ───────────────────────────────┐\n│ (print, len, str, etc.)                        │\n│ ┌─ GLOBAL SCOPE ─────────────────────────────┐ │\n│ │ global_var = 100                           │ │\n│ │ ┌─ ENCLOSING SCOPE ──────────────────────┐ │ │\n│ │ │ def outer_function():                  │ │ │\n│ │ │     outer_var = 200                    │ │ │\n│ │ │ ┌─ LOCAL SCOPE ──────────────────────┐ │ │ │\n│ │ │ │ def inner_function():              │ │ │ │\n│ │ │ │     local_var = 300                │ │ │ │\n│ │ │ │     print(local_var)               │ │ │ │\n│ │ │ │     print(outer_var)               │ │ │ │\n│ │ │ │     print(global_var)              │ │ │ │\n│ │ │ └────────────────────────────────────┘ │ │ │\n│ │ └────────────────────────────────────────┘ │ │\n│ └────────────────────────────────────────────┘ │\n└────────────────────────────────────────────────┘\n\nBuilt-in Scope: Contains Python’s pre-built functions and tools that are always available\nGlobal Scope: Where your main program variables live\nEnclosing Scope: Contains variables from outer functions\nLocal Scope: Contains variables defined within the current function\n\nWhen your code needs to use a variable, Python looks for it starting from the innermost scope (local) and works its way outward until it finds it. This is why you can use global variables inside functions, but you can’t use local variables outside their functions.\n\n\nSpecial Cases in Python Scope\nWhile we’ve covered the main rules of scope, Python has a few special situations that work a bit differently. Let’s look at three interesting cases that might surprise you.\n\nList Comprehensions Keep Their Variables Private\nWhen you use a list comprehension (that shorthand way to create lists), Python handles its variables differently than regular loops. Here’s what I mean:\n\n%reset -f\n\n# This list comprehension doubles each number from 0 to 4\nnumbers = [x * 2 for x in range(5)]\nprint(numbers)\n\n# Try to access 'x' - it won't work!\ntry:\n    x\nexcept NameError as error:\n    print(error)\n\n[0, 2, 4, 6, 8]\nname 'x' is not defined\n\n\nCompare this to a regular for loop, where the loop variable sticks around:\n\n%reset -f\n\n# Regular for loop doing the same thing\nnumbers = []\nfor x in range(5):\n    numbers.append(x * 2)\nprint(numbers)\n\n# Here we can still use 'x' - it exists!\nprint(x)\n\n[0, 2, 4, 6, 8]\n4\n\n\n\n\nError Variables Stay in Their Block\nWhen handling errors (which we’ll cover more in a later tutorial), variables created in except blocks are only available within that block:\n\ntry:\n    1 / 0\nexcept ZeroDivisionError as error:\n    print(error)  # Works here\n\n# Try to use 'error' later...\ntry:\n    print(error)  # Won't work!\nexcept NameError:\n    print(\"can't get the original 'error' here\")\n\ndivision by zero\ncan't get the original 'error' here\n\n\nThese special cases are part of Python’s design to prevent variables from accidentally leaking into parts of your code where they weren’t intended to be used. While they might seem like quirks at first, they actually help keep your code cleaner and more predictable.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions.html#best-practices-for-writing-functions",
    "href": "chapters/04_functions.html#best-practices-for-writing-functions",
    "title": "4  Functions",
    "section": "Best Practices for Writing Functions",
    "text": "Best Practices for Writing Functions\nWhen you’re learning to write functions, you’ll find lots of advice online, some of it contradictory! However, most guidelines share a common goal: making your code easier to understand and maintain. Here are some practical tips to help you write better functions from the start.\n\nUse Clear, Meaningful Names\nFunction names are like labels on laboratory equipment – they should clearly indicate what they do:\n\n# Not very helpful\ndef calc(x, y):\n    return x * y\n\n\n# Much clearer\ndef area(length, width):\n    return length * width\n\nStay consistent with your naming style. Pick one approach and stick with it:\n\n# Inconsistent naming\ndef area(length, width): ...\ndef getPerimeter(l, w): ...\ndef calcvolume(x, y, z): ...\n\n\n# Better -- consistent and clear\ndef area(length, width): ...\ndef perimeter(length, width): ...\ndef volume(length, width, height): ...\n\n\n\nKeep Functions Focused and Concise\nEach function should do one specific task well. If you find your function doing multiple different things, it’s usually better to split it into smaller, more focused functions.\nHere’s an example analyzing a DNA sequence:\n\n# Too many tasks in one function\ndef process_dna_sequence(sequence):\n    has_start = sequence.startswith(\"ATG\")\n    has_stop = sequence.endswith((\"TAA\", \"TAG\", \"TGA\"))\n    gc_content = (sequence.count(\"G\") + sequence.count(\"C\")) / len(sequence)\n    return has_start, has_stop, nucleotide_counts, gc_content\n\n\n# Better: Split into focused functions\ndef has_start_codon(sequence):\n    return sequence.startswith(\"ATG\")\n\n\ndef has_stop_codon(sequence):\n    return sequence.endswith((\"TAA\", \"TAG\", \"TGA\"))\n\n\ndef calculate_gc_percentage(sequence):\n    gc_count = sequence.count(\"G\") + sequence.count(\"C\")\n    return gc_count / len(sequence) * 100\n\n\n\nMake Function Behavior Clear and Predictable\nWhen writing functions, make it obvious what data the function needs to do its job. Pass required data directly to the function rather than having it rely on information defined elsewhere in your code.\n\n# Less clear -- relies on external data\nmeasurements = []\n\n\ndef add_measurement(new_measurement):\n    measurements.append(new_measurement)\n    return sum(measurements) / len(measurements)\n\n\n# Better -- everything the function needs is passed directly\ndef add_measurement(measurements, new_measurement):\n    measurements.append(new_measurement)\n    return sum(measurements) / len(measurements)\n\n\n\nWhen Should You Write a Function?\nConsider writing a function when:\n\nYou have a specific task that you can clearly define\nYou find yourself copying and pasting similar code multiple times\nYou want to make complex operations easier to understand\nYou plan to reuse the same code in different parts of your project\n\n\n\nSummary\nThese guidelines will help you write functions that are easier to understand, test, and maintain. As you gain experience, you’ll develop an intuition for when and how to apply these practices. Remember, the goal is to write code that both you and others can easily work with, even months or years after it was written.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions.html#sec-function-docs",
    "href": "chapters/04_functions.html#sec-function-docs",
    "title": "4  Functions",
    "section": "Function Documentation: Making Your Code Clear and Useful",
    "text": "Function Documentation: Making Your Code Clear and Useful\nYou could think of documentation as leaving helpful instructions for yourself and others about how your code works. While it might seem tedious at first, good documentation is like a roadmap that helps people understand and use your code correctly.\nLet’s look at an example of a function without documentation:\n\ndef math_monster_addition(a, b):\n    if a &gt;= b:\n        return a + b\n    else:\n        return a - b\n\nLooking at this code, you can figure out what it does, but not why it exists or when you should use it. Let’s improve it by adding proper documentation:\n\ndef add_or_subtract(a, b):\n    \"\"\"\n    Performs addition or subtraction based on the relative values of two numbers.\n\n    This function models the Math Monster's arithmetic behavior.  When the\n    first number is bigger (or equal), the monster is happy and adds the\n    numbers.  When the first number is smaller, the monster gets grumpy and\n    subtracts them instead.\n\n    Args:\n        a (numeric): First number\n        b (numeric): Second number\n\n    Returns:\n        numeric: The sum of a and b if a is greater than or equal to b,\n          otherwise returns the difference (a - b).\n\n    Examples:\n        &gt;&gt;&gt; add_or_subtract(5, 3)  #=&gt;  8\n        &gt;&gt;&gt; add_or_subtract(2, 7)  #=&gt; -5\n        &gt;&gt;&gt; add_or_subtract(1, 1)  #=&gt;  2\n    \"\"\"\n    if a &gt;= b:\n        return a + b\n    else:\n        return a - b\n\n\nKey Parts of Good Documentation\n\nSummary Line: A brief, clear statement of what the function does.\nDescription: More detailed explanation of the function’s purpose and behavior.\nArgs: List of parameters with their types and descriptions.\nReturns: What the function gives back and under what conditions.\nExamples: Real-world usage examples showing inputs and outputs.\n\n\n\nDocumentation Style\nWhile there are several ways to format documentation (like Google’s style shown above), what matters most is consistency. Pick one style and stick with it throughout your project. You can explore different styles in Real Python’s documentation guide.\n\n\nWhy Documentation Matters\nGood documentation:\n\nMakes your code more accessible to others\nHelps you remember how your own code works months later\nCan reveal problems in your code design\nMakes your code more maintainable\nEnables automatic documentation generation\n\n\n\nA Note on Writing Documentation\nIf you find it difficult to write clear documentation for a function, it might be a sign that the function is too complex or trying to do too many things. Use documentation as an opportunity to review and potentially simplify your code.\nRemember: The goal isn’t to document every single line of code, but to provide enough information so that someone (including future you) can understand and use your code effectively.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions.html#advanced-topics",
    "href": "chapters/04_functions.html#advanced-topics",
    "title": "4  Functions",
    "section": "Advanced Topics",
    "text": "Advanced Topics\nLet’s explore a few more interesting features of Python functions that you might encounter in your programming journey.\n\nFunction Names and Aliases\nThink of function names as labels. You can create multiple labels (aliases) that point to the same function, similar to how you might have different names for the same thing:\n\ndef add1(x):\n    return x + 1\n\n\n# Create another name for the same function\nadd_one = add1\n\nprint(add1(2))  # Prints 3\nprint(add_one(2))  # Also prints 3\n\n3\n3\n\n\nThis can be useful when you want to use a more context-appropriate name:\n\ndef calculate_tax(amount):\n    return amount * 0.2\n\n\n# Using a more specific name for sales contexts\nsales_tax = calculate_tax\n\nprice = 100\ntax = sales_tax(price)  # Clearer what this represents\n\nEven when two functions do exactly the same thing, Python treats them as distinct objects if they’re defined separately:\n\ndef add1(x):\n    return x + 1\n\n\ndef add_one(x):\n    return x + 1\n\n\nprint(\"add1 points to\", add1)\nprint(\"add_one points to\", add_one)\nprint(\"add1 == add_one is\", add1 == add_one)\n\nprint(f\"add1(2) == {add1(2)}\")\nprint(f\"add_one(2) == {add_one(2)}\")\n\nadd1 points to &lt;function add1 at 0x124ec3a60&gt;\nadd_one points to &lt;function add_one at 0x124ec0040&gt;\nadd1 == add_one is False\nadd1(2) == 3\nadd_one(2) == 3\n\n\n\n\nFunctions as Objects\nIn Python, functions are objects that you can work with just like numbers or strings. Here’s a practical example using Python’s sorted function:\n\n# Default sorting (alphabetical)\nwords = [\"apple\", \"pie\", \"is\", \"good\"]\nsorted_words = sorted(words)\nprint(sorted_words)\n\n# Sorting by length instead.  Here, `len` is the built-in length function.\nsorted_words = sorted(words, key=len)\nprint(sorted_words)\n\n['apple', 'good', 'is', 'pie']\n['is', 'pie', 'good', 'apple']\n\n\nWe can also write our own functions to customize sorting. Here’s an example with student grades:\n\ndef get_grade(student):\n    return student[1]\n\n\nstudent_grades = [(\"Pikachu\", 97), (\"Charmander\", 91), (\"Bulbasaur\", 86)]\nsorted_student_grades = sorted(student_grades, key=get_grade)\nprint(sorted_student_grades)\n\n[('Bulbasaur', 86), ('Charmander', 91), ('Pikachu', 97)]\n\n\n\n\nLambda Expressions\nSometimes writing a full function is overkill for a simple operation. That’s where lambda expressions come in – they’re tiny, unnamed functions:\nstudent_grades = [(\"Pikachu\", 97), (\"Charmander\", 91), (\"Bulbasaur\", 86)]\nsorted_student_grades = sorted(student_grades, key=lambda student: student[1])\nprint(sorted_student_grades)\nWhile you can store lambda functions in variables, it’s usually better to write a regular function if you plan to reuse the code.\n\n\nType Hints\nYou might see functions written with extra information about their inputs and outputs:\n\ndef greet(name: str) -&gt; str:\n    return f\"Hello, {name}!\"\n\n\ndef add(a: int, b: int) -&gt; int:\n    return a + b\n\nThese are called type hints. They help document:\n\nWhat kind of data a function expects (like name: str meaning “name should be a string”)\nWhat kind of data it returns (like -&gt; str meaning “returns a string”)\n\nKey points about type hints:\n\nThey’re optional\nPython doesn’t enforce them automatically\nThey’re fairly common in larger projects\nYou can ignore them while learning Python\n\nType hints are helpful for documentation and code maintenance, but your code will work perfectly fine without them!",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions.html#wrap-up",
    "href": "chapters/04_functions.html#wrap-up",
    "title": "4  Functions",
    "section": "Wrap-Up",
    "text": "Wrap-Up\nFunctions are one of the most fundamental and powerful concepts in Python programming. In this tutorial, we’ve covered everything from basic function syntax to advanced topics like variable-length arguments and scope rules. You’ve learned how to write clear, reusable code by packaging logic into well-named functions, how to work with different types of parameters, and how to use return values effectively. We’ve also explored important concepts like variable scope, documentation best practices, and some advanced features like lambda expressions and type hints. With this foundation in functions, you’re now equipped to write more organized, maintainable, and self-documenting Python code that can be easily shared and reused across your bioinformatics projects.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/04_functions.html#suggested-readings",
    "href": "chapters/04_functions.html#suggested-readings",
    "title": "4  Functions",
    "section": "Suggested Readings",
    "text": "Suggested Readings\nYou might enjoy checking out some of these resources:\n\nPython Docs: 4.8. Defining Functions\nGoogle Python Style Guide: Functions and Methods\nReal Python: Python Scope & the LEGB Rule: Resolving Names in Your Code\nType hints cheat sheet",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Functions</span>"
    ]
  },
  {
    "objectID": "chapters/05_classes.html",
    "href": "chapters/05_classes.html",
    "title": "5  Introduction to Object-Oriented Programming",
    "section": "",
    "text": "Four Pillars of OOP\nThink about the natural world around you for a moment. You can imagine birds, trees, cells, and countless other entities. Each of these things has specific characteristics and behaviors that help you recognize them. One way to turn these entities into code is by using Classes and Objects.\nIn programming terms, an object is sort of like a specific entity that exists in the real world:\nJust like real-world things, objects have two key aspects:\nFor example, that robin outside your window has a particular color (characteristic) and can sing a specific song (behavior). The E. coli cell in your Petri dish has a particular size (characteristic) and can metabolize lactose (behavior).\nIf objects are the specific things (like a particular robin or E. coli cell) in your domain, then classes are the blueprints or templates that define the characteristics and behaviors of those entities.\nFor instance, the Robin class might specify that all robins have characteristics like species, wingspan, feather color, beak shape, plus behaviors such as flying, singing, and nest-building. But each individual robin instance would have its own specific values for these characteristics and behaviors that depend on those specific characteristics.\nClasses enable us to create our own custom data types that model real-world entities. Instead of just having numbers and strings, we can have Birds, Bacteria, Patients, Proteins, and Molecules, each with their own specialized characteristics and behaviors.\nThis connection between our programs and the real-world domain we are modeling is what makes object-oriented programming powerful. It allows us to represent and manipulate complex biological entities in a way that feels natural and intuitive, mirroring how we already think about these systems in our research.\nFor the rest of this tutorial, we’ll explore how to implement Object-Oriented Programming (OOP) in Python, giving you the tools to represent the biological systems you work with in a natural way.\nWhen learning about object-oriented programming (OOP), you’ll often hear about four fundamental concepts (pillars) that form its foundation. These concepts help us organize code in a way that mirrors how we think about real-world objects and their relationships:\nWe’ll introduce some of these concepts at a practical level in this tutorial and continue to explore them throughout the course.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "chapters/05_classes.html#sec-four-pillars-oop",
    "href": "chapters/05_classes.html#sec-four-pillars-oop",
    "title": "5  Introduction to Object-Oriented Programming",
    "section": "",
    "text": "Encapsulation: bundling data and methods that work on that data into a single unit (a class)\n\nRestricts direct access to some components\nProtects internal state of an object\nHides data\n\nAbstraction: showing only essential features while hiding complicated implementation details\nPolymorphism: objects of different classes responding to the same method in their own ways\nInheritance: creating new classes that receive attributes and methods from existing classes",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "chapters/05_classes.html#sec-class-basics",
    "href": "chapters/05_classes.html#sec-class-basics",
    "title": "5  Introduction to Object-Oriented Programming",
    "section": "Classes in Python: Syntax and Structure",
    "text": "Classes in Python: Syntax and Structure\nNow that we have some conceptual framework for object-oriented programming, let’s look at how to write classes in Python. To define a class, we use the class keyword, followed by the name of the class. In the indented section that follows, we can define variables and functions that will be associated with the class and with instances of the class:\n\n# Define a class named \"Robin\".\n#\n# (Class names look LikeThis rather than like_this.)\nclass Robin:\n    # Class Attributes\n    common_name = \"American Robin\"\n    species = \"Turdus migratorius\"\n    beak_shape = \"pointy\"\n\n    # The special method to initialize instances of this class\n    def __init__(self, wingspan, weight, color):\n        self.wingspan = wingspan\n        self.weight = weight\n        self.color = color\n\n    # Define some instance methods that describe the behavior that Robins\n    # will have.\n\n    # Each of these methods will use `id(self)` so that you can see the identity\n    # of the object that it is being called on.\n\n    def fly(self, to):\n        print(f\"robin {id(self)} is flying to {to}!\")\n\n    def sing(self):\n        print(f\"robin {id(self)} is singing!\")\n\n    def eat(self, what):\n        print(f\"robin {id(self)} is eating {what}!\")\n\n    def build_nest(self, where):\n        print(f\"robin {id(self)} is building a nest {where}!\")\n\nCreating an instance of a class looks a lot like calling a function:\n\nrobin = Robin(wingspan=35, weight=80, color=\"gray & reddish brown\")\n\nYou can access the instance attributes using the “dot” syntax:\n\nprint(\n    f\"You see a {robin.color} robin \"\n    f\"that weighs {robin.weight} grams \"\n    f\"with a wingspan of {robin.wingspan} centimeters!\"\n    \"\\nThat's a nice find!!\\n\"\n)\n\nYou see a gray & reddish brown robin that weighs 80 grams with a wingspan of 35 centimeters!\nThat's a nice find!!\n\n\n\nEven though we specified what each of the objects attributes should be when we created it, that doesn’t mean we can’t change them later if we need to. Let’s say our robin eats a worm, and then it gains a little weight afterwards:\n\n# Show the robin's current weight\nprint(f\"before eating the worm, the robin weighs {robin.weight} grams\")\n\n# The robin eats the worm\nrobin.eat(\"a delicious worm\")\n\n# Then it gains 2 grams of weight\nrobin.weight += 2\n\n# Show the robin's weight again\nprint(f\"after eating the worm, the robin weighs {robin.weight} grams\")\n\nbefore eating the worm, the robin weighs 80 grams\nrobin 4431446768 is eating a delicious worm!\nafter eating the worm, the robin weighs 82 grams\n\n\nWe can access the object’s behavior by “calling” its methods:\n\nrobin.sing()\nrobin.fly(to=\"Mexico\")\nrobin.eat(what=\"a worm\")\nrobin.build_nest(where=\"in a tree\")\n\nrobin 4431446768 is singing!\nrobin 4431446768 is flying to Mexico!\nrobin 4431446768 is eating a worm!\nrobin 4431446768 is building a nest in a tree!\n\n\nMultiple distinct instances of the Robin class can be created. Check out how each of them has a different ID:\n\nrobin_1 = Robin(wingspan=35, weight=80, color=\"gray & reddish brown\")\nrobin_2 = Robin(wingspan=32, weight=78, color=\"gray & brownish orange\")\nrobin_3 = Robin(wingspan=36, weight=79, color=\"gray & reddish brown\")\n\nprint(robin_1)\nprint(robin_2)\nprint(robin_3)\n\nrobin_1.sing()\nrobin_2.sing()\nrobin_3.sing()\n\n&lt;__main__.Robin object at 0x110b774d0&gt;\n&lt;__main__.Robin object at 0x110b77390&gt;\n&lt;__main__.Robin object at 0x108186520&gt;\nrobin 4575425744 is singing!\nrobin 4575425424 is singing!\nrobin 4430783776 is singing!\n\n\nEven though all three of the Robin objects were created from the same class, they are distinct entities in our program. If we change something about one of them, it won’t change the others:\n\nprint(\n    \"before changing weight and color of robin 1,\",\n    \"the weight and color of robin 2 are:\",\n)\nprint(robin_2.weight)\nprint(robin_2.color)\n\n\nrobin_1.weight += 1\nrobin_1.color = \"mostly gray, with some reddish brown\"\n\nprint(\n    \"\\nafter changing weight and color of robin 1,\",\n    \"the weight and color of robin 2 are:\",\n)\nprint(robin_2.weight)\nprint(robin_2.color)\n\nbefore changing weight and color of robin 1, the weight and color of robin 2 are:\n78\ngray & brownish orange\n\nafter changing weight and color of robin 1, the weight and color of robin 2 are:\n78\ngray & brownish orange\n\n\nFinally, we can even give objects completely new attributes if we want to:\n\nrobin_1.favorite_food = \"french fries\"\n\nprint(robin_1.favorite_food)\n\nfrench fries\n\n\nBe careful with this though. That attribute will not be available on all your objects. It will only exist on the specific object where you explicitly added it:\n\ntry:\n    print(robin_2.favorite_food)\nexcept AttributeError as error:\n    print(error)\n\n'Robin' object has no attribute 'favorite_food'\n\n\nNext, let’s dig into some more of the details of creating and using classes in Python.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "chapters/05_classes.html#initializing-objects",
    "href": "chapters/05_classes.html#initializing-objects",
    "title": "5  Introduction to Object-Oriented Programming",
    "section": "Initializing Objects",
    "text": "Initializing Objects\nWhen you instantiate an object from a class in Python, it doesn’t simply create an empty shell. Instead, it invokes a special initialization method called __init__ (if defined). This method serves as the object’s constructor, handling the necessary setup to ensure the newly created object is fully functional.\nLet’s make a new class called BlueJay to illustrate some of the details:\n\nclass BlueJay:\n    def __init__(self):\n        self.wingspan = 38  # centimeters\n        self.color = \"blue\"\n\nIn this class, the init method takes only one parameter, self, which refers to the newly created object. It assigns the instance attribute color a default value of “blue”. Take a look:\n\nblue_jay = BlueJay()\nprint(blue_jay)\nprint(blue_jay.wingspan)\nprint(blue_jay.color)\n\n# We can change the value of an instance attribute after the object is created.\nblue_jay.wingspan = 35\nblue_jay.color = \"shockingly blue\"\n\nprint(blue_jay.wingspan)\nprint(blue_jay.color)\n\n&lt;__main__.BlueJay object at 0x1082281a0&gt;\n38\nblue\n35\nshockingly blue\n\n\nCreating an object then immediately updating its attributes is such a common operation that Python lets you do it all in one step. This is done by adding additional parameters to the __init__ function:\n\nclass BlueJay:\n    def __init__(self, wingspan, color):\n        self.wingspan = wingspan\n        self.color = color\n\n\nblue_jay = BlueJay(wingspan=36, color=\"bright blue\")\nprint(blue_jay)\nprint(blue_jay.wingspan)\nprint(blue_jay.color)\n\n&lt;__main__.BlueJay object at 0x110b1b230&gt;\n36\nbright blue\n\n\nNow, we need to call BlueJay and provide the color and wingspan arguments. Failing to do so will result in an error:\n\ntry:\n    BlueJay()\nexcept TypeError as error:\n    print(error)\n\nBlueJay.__init__() missing 2 required positional arguments: 'wingspan' and 'color'\n\n\nThe error hints at Python’s inner workings. It mentions that two required arguments are missing: color and wingspan. But hang on, doesn’t __init__ have three parameters?\nIt does! This reveals how Python handles class instantiation: it first creates the object (via __new__ behind the scenes), then initializes it with __init__.\nWhen initializing, Python automatically passes the new object as the first argument (typically called self, but you could name it anything). You only need to provide the remaining arguments – hence the error about missing two arguments, not three.\nRemember that __init__ works like any other Python function. You can use all the parameter options we covered earlier (see Section 4.3), such as default values for parameters like color:\n\nclass BlueJay:\n    def __init__(self, wingspan, color=\"blue\"):\n        self.wingspan = wingspan\n        self.color = color\n\nblue_jay = BlueJay(wingspan=35)\n\nprint(blue_jay.color)\n\nblue\n\n\n\nValidating Inputs\nThe __init__ method plays a crucial role in validating data when creating class instances. For example, if we need to ensure birds can’t have negative wingspans or empty color strings, we can build these checks directly into initialization. When someone creates a bird with invalid data, instead of failing, the code can substitute sensible defaults. This approach guarantees that all instances meet our basic requirements, protecting against bad input:\n\nclass BlueJay:\n    def __init__(self, wingspan, color=\"blue\"):\n        if wingspan &lt; 0:\n            self.wingspan = 0\n        else:\n            self.wingspan = wingspan\n\n        if color == \"\":\n            self.color = \"blue\"\n        else:\n            self.color = color\n\n\nblue_jay = BlueJay(-234, \"\")\nprint(blue_jay.wingspan)\nprint(blue_jay.color)\n\n0\nblue\n\n\nIf you can’t identify a reasonable default value, the most straightforward approach is to simply raise an error. This strategy helps to prevent failures later on.\n\nclass Bird:\n    def __init__(self, species):\n        if species == \"\":\n            raise ValueError(\"species name cannot be blank\")\n\n\ntry:\n    Bird(\"\")\nexcept ValueError as error:\n    print(error)\n\nspecies name cannot be blank",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "chapters/05_classes.html#attributes",
    "href": "chapters/05_classes.html#attributes",
    "title": "5  Introduction to Object-Oriented Programming",
    "section": "Attributes",
    "text": "Attributes\nAttributes are the data that is associated with the class and with instances of that class.\n\nInstance Attributes\nWhen initializing a BlueJay object, the __init__ function sets up two attributes: wingspan and color. The self parameter refers to the actual instance being created, so self.wingspan = 1234 creates a wingspan attribute on your new BlueJay object.\nInstance attributes are not shared between different instances of the same class:\n\ntiny_blue_jay = BlueJay(wingspan=28)\nbig_blue_jay = BlueJay(wingspan=40)\n\nprint(tiny_blue_jay.wingspan)\nprint(big_blue_jay.wingspan)\n\n28\n40\n\n\nIf we change one after creation, it will not affect the other:\n\ntiny_blue_jay.wingspan += 1\n\nprint(tiny_blue_jay.wingspan)\nprint(big_blue_jay.wingspan)\n\n29\n40\n\n\nNice! Each object independently manages its state, completely separate from other objects. Just be careful with mutable values in instance attributes though. For example, if you store a bird’s colors as a list (since birds can have multiple colors), you might run into some unexpected behavior:\n\ncolors = [\"blue\", \"white\", \"black\"]\n\n# Create two BlueJay instances with the same color list.\ntiny_blue_jay = BlueJay(wingspan=28, color=colors)\nbig_blue_jay = BlueJay(wingspan=40, color=colors)\nprint(tiny_blue_jay.color)\nprint(big_blue_jay.color)\n\n# Can you guess what will happen if we change one of the colors?\ntiny_blue_jay.color[0] = \"electric blue\"\nprint(\"\\nafter changing color[0] of tiny_blue_jay\")\nprint(tiny_blue_jay.color)\nprint(big_blue_jay.color)\n\n# Or add a color to one of them?\nprint(\"\\nafter appending a new color to big_blue_jay\")\nbig_blue_jay.color.append(\"light blue\")\nprint(tiny_blue_jay.color)\nprint(big_blue_jay.color)\n\n['blue', 'white', 'black']\n['blue', 'white', 'black']\n\nafter changing color[0] of tiny_blue_jay\n['electric blue', 'white', 'black']\n['electric blue', 'white', 'black']\n\nafter appending a new color to big_blue_jay\n['electric blue', 'white', 'black', 'light blue']\n['electric blue', 'white', 'black', 'light blue']\n\n\nI know I just explained that instance attributes are independent between objects, which might seem contradictory here. But remember our discussion about mutable parameters back in Section 4.5.4.1? Python variables are actually references to objects, not the objects themselves. In the example, both BlueJay instances ended up referencing the identical list object. Keep this behavior in mind: it’s a common source of subtle bugs.\nAs mentioned earlier, you can add more instance attributes to an object after creation:\n\nblue_jay = BlueJay(wingspan=35)\n\nblue_jay.sneakiness = \"very sneaky\"\n\nprint(f\"this blue jay is {blue_jay.sneakiness}!\")\n\nthis blue jay is very sneaky!\n\n\n\n\nClass Attributes\nIn our earlier look at the Robin class in Section 5.2, we used class attributes for data shared across all instances. This approach is ideal for information common to all robins, things like common name, species, and beak shape. Class attributes make sense when the data belongs to the entire group rather than to specific individuals.\nClass attributes are defined directly within the class, but outside any methods:\n\nclass BlueJay:\n    common_name = \"Blue Jay\"\n    species = \"Cyanocitta cristata\"\n    beak_shape = \"medium-length, conical\"\n\n\nblue_jay = BlueJay()\n\nprint(blue_jay.species)\nprint(blue_jay.beak_shape)\n\nCyanocitta cristata\nmedium-length, conical\n\n\nYou can also access class attributes directly on the class object itself:\n\nprint(BlueJay.species)\nprint(BlueJay.beak_shape)\n\nCyanocitta cristata\nmedium-length, conical\n\n\nAside: that might seem a bit weird, but in Python, classes themselves are also objects that have properties and methods:\n\nprint(BlueJay.__class__)\n\n&lt;class 'type'&gt;\n\n\nWe will talk more about this later in the course.\nLet’s update the BlueJay class to have both class and instance attributes:\n\nclass BlueJay:\n    # Set class attributes\n    common_name = \"Blue Jay\"\n    species = \"Cyanocitta cristata\"\n    beak_shape = \"medium-length, conical\"\n\n    def __init__(self, wingspan=38, color=\"blue\"):\n        # Set instance attributes\n        self.wingspan = wingspan\n        self.color = color\n\n\ntiny_blue_jay = BlueJay(wingspan=28)\nbig_blue_jay = BlueJay(wingspan=40)\n\n# All blue jays will have the same values for the class attributes, but likely\n# have different values for the instance attributes.\nprint(tiny_blue_jay.wingspan, tiny_blue_jay.species)\nprint(big_blue_jay.wingspan, big_blue_jay.species)\n\n28 Cyanocitta cristata\n40 Cyanocitta cristata\n\n\n\nModifying Class Attributes\nClass attributes don’t have to be constant, unchanging things. Let’s look at an example where we change the value of a class attribute from within an instance method to create sequential IDs for instances of that class. Check it out:\n\nclass Amoeba:\n    # This is a class attribute\n    counter = 0\n\n    def __init__(self, name=None):\n        # We increment the value stored in the counter class attribute by 1.\n        Amoeba.counter += 1\n\n        # Then, we set that value to the value of this amoeba instance's `id`\n        # attribute.\n        self.id = Amoeba.counter\n\n        # If the user doesn't specify a name, then we create a default name\n        # that includes the ID.\n        if name is None:\n            self.name = f\"Amoeba_{self.id}\"\n        else:\n            self.name = name\n\n\namoeba_1 = Amoeba()\namoeba_2 = Amoeba(name=\"Bob the Amoeba\")\namoeba_3 = Amoeba()\n\nprint(amoeba_1.name)\nprint(amoeba_2.name)\nprint(amoeba_3.name)\n\nAmoeba_1\nBob the Amoeba\nAmoeba_3\n\n\nPretty neat! We will go into more fancy details like this in a future tutorial.\n\n\nA Tricky Example\nIn our last example, we contained mutations within class methods—a safer approach than external state modification, which often causes bugs. Let’s flip this and see what happens when we modify class variables from outside. Warning: it gets a bit confusing!\n\nprint(\"tiny_blue_jay species:\", tiny_blue_jay.species, id(tiny_blue_jay.species))\nprint(\"big_blue_jay species:\", big_blue_jay.species, id(big_blue_jay.species))\nprint()\n\ntiny_blue_jay.species = \"i don't know!\"\n\nprint(\"tiny_blue_jay species:\", tiny_blue_jay.species, id(tiny_blue_jay.species))\nprint(\"big_blue_jay species:\", big_blue_jay.species, id(big_blue_jay.species))\nprint()\n\nBlueJay.species = \"something else\"\n\nprint(\"tiny_blue_jay species:\", tiny_blue_jay.species, id(tiny_blue_jay.species))\nprint(\"big_blue_jay species\", big_blue_jay.species, id(big_blue_jay.species))\nprint()\n\nanother_blue_jay = BlueJay()\nprint(\n    \"another_blue_jay species:\",\n    another_blue_jay.species,\n    id(another_blue_jay.species),\n)\n\ntiny_blue_jay species: Cyanocitta cristata 4431899312\nbig_blue_jay species: Cyanocitta cristata 4431899312\n\ntiny_blue_jay species: i don't know! 4431733680\nbig_blue_jay species: Cyanocitta cristata 4431899312\n\ntiny_blue_jay species: i don't know! 4431733680\nbig_blue_jay species something else 4431699760\n\nanother_blue_jay species: something else 4431699760\n\n\nLet’s break this down:\n\nInitially, all BlueJay instances share the class attribute species with value \"Cyanocitta cristata\" (note the matching IDs in the first two lines).\nWhen we set tiny_blue_jay.species = \"i don't know!\", we’re not changing the class attribute, we’re creating a new instance attribute that shadows it. The ID changes for tiny_blue_jay but stays the same for big_blue_jay.\nWith BlueJay.species = \"something else\", we modify the actual class attribute. This affects all instances that don’t have their own shadowing attribute—big_blue_jay sees the new value, but tiny_blue_jay still shows its instance-specific value.\nAny new instance (like another_blue_jay) gets the updated class attribute value.\n\nThe apparent complexity stems from Python’s attribute lookup sequence:\n\nCheck the instance namespace first\nThen check the class namespace\nFinally, check parent classes\n\nThis enables both shared values and individual customization with the same name. This is very flexible, but potentially confusing if you don’t understand the lookup mechanism.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "chapters/05_classes.html#methods",
    "href": "chapters/05_classes.html#methods",
    "title": "5  Introduction to Object-Oriented Programming",
    "section": "Methods",
    "text": "Methods\nMethods are functions inside classes that usually work with instances of that class. Class methods exist too (like class attributes), but we’ll skip those for now.\nOur previous examples were pretty basic. Let’s look at something a bit more interesting to showcase why classes and objects are actually useful.\n\nclass Amoeba:\n    \"\"\"\n    Represent an amoeba with position and energy tracking.\n\n    This class models an amoeba that can move around in a 2D space and manage\n    its energy levels. Each amoeba has a unique ID, position coordinates, and\n    energy value.\n\n    Attributes:\n        counter (int): Class variable that keeps track of how many amoeba instances\n            have been created.\n        id (str): Unique identifier for each amoeba instance.\n        position (list): A list of two integers representing [x, y] coordinates.\n        energy (int): Current energy level of the amoeba.\n    \"\"\"\n\n    counter = 0\n\n    def __init__(self, position=None, energy=5):\n        Amoeba.counter += 1\n        self.id = f\"Amoeba #{Amoeba.counter}\"\n\n        if position is None:\n            self.position = [0, 0]\n        else:\n            self.position = position\n\n        self.energy = energy\n\n    # This method controls how Amoebas will be printed\n    def __str__(self):\n        return f\"{self.id} -- Position: {self.position}, Energy: {self.energy}\"\n\n    def move(self, direction):\n        \"\"\"Move the amoeba, consuming energy.\"\"\"\n\n        if self.energy &lt;= 0:\n            print(f\"{self.id} is too weak to move!\")\n            return\n\n        if direction == \"right\":\n            print(f\"{self.id} moves right!\")\n            # Moving to the right means adding one to the x position\n            self.position[0] += 1\n        elif direction == \"left\":\n            print(f\"{self.id} moves left!\")\n            # Moving to the left means subtracting one from the x position\n            self.position[0] -= 1\n        elif direction == \"up\":\n            print(f\"{self.id} moves up!\")\n            # Moving up means adding one to the y position\n            self.position[1] += 1\n        elif direction == \"down\":\n            print(f\"{self.id} moves down!\")\n            # Moving down means subtracting one from the y position\n            self.position[1] -= 1\n        else:\n            raise ValueError(\"direction must one of up, down, left, or right\")\n\n        self.energy -= 1\n\n    def eat(self):\n        \"\"\"The amoeba eats, increasing its energy.\"\"\"\n        print(f\"{self.id} eats\")\n        self.energy += 2\n\nThere are a lot of things to break down about the Amoeba class. Let’s look at a few key points:\n\nClass attributes vs. Instance attributes:\n\ncounter is a class attribute shared across all instances\nid, position, and energy are instance attributes unique to each object\n\nConstructor Implementation:\n\nUses __init__ to set up each new amoeba with its initial state\nAutomatically increments the counter to assign unique IDs\nHandles default parameters (position=None, energy=5)\nSets a default position if none is provided\n\nString Representation:\n\nImplements __str__ to provide a human-readable representation\nReturns formatted string containing the amoeba’s ID, position and energy\n\n`move() Method Implementation:\n\nmove() validates input parameters\nChecks current state before performing actions (if self.energy &lt;= 0)\nDemonstrates internal state modification (changing position and reducing energy)\nShows error handling with a descriptive error message (ValueError) for bad inputs\n\n2D Movement Representation:\n\nUses a list [x, y] to represent position in 2D space\nAdjusts coordinates based on movement direction\n\nState Management:\n\nClass methods track and update the amoeba’s internal state (position, energy)\nBehavior depends on internal state (the amoeba can’t move with 0 energy)\n\nCode Organization:\n\nUses docstrings for class and method documentation\nFollows consistent indentation and naming conventions (methods names are short verbs)\n\n\nNow, let’s try it out!\n\nimport random\n\n# These are the four directions that an amoeba can move\nfour_directions = [\"up\", \"down\", \"left\", \"right\"]\n\n# Seed the random generator so that we get the same result each time we run the code\nrandom.seed(37424)\n\n# Generate a random \"walk\"\ndirections = random.choices(four_directions, k=10)\n\n# Create a new amoeba instance\namoeba = Amoeba()\n\n# Go through each of the moves one by one\nfor direction in directions:\n    print(amoeba)\n\n    # Each turn, the amoeba has a 1/5 chance in eating some lunch\n    if random.random() &lt; 0.2:\n        amoeba.eat()\n\n    # Then the amoeba tries to move\n    amoeba.move(direction)\n    print()\n\nAmoeba #1 -- Position: [0, 0], Energy: 5\nAmoeba #1 eats\nAmoeba #1 moves down!\n\nAmoeba #1 -- Position: [0, -1], Energy: 6\nAmoeba #1 moves down!\n\nAmoeba #1 -- Position: [0, -2], Energy: 5\nAmoeba #1 moves left!\n\nAmoeba #1 -- Position: [-1, -2], Energy: 4\nAmoeba #1 eats\nAmoeba #1 moves down!\n\nAmoeba #1 -- Position: [-1, -3], Energy: 5\nAmoeba #1 moves up!\n\nAmoeba #1 -- Position: [-1, -2], Energy: 4\nAmoeba #1 moves down!\n\nAmoeba #1 -- Position: [-1, -3], Energy: 3\nAmoeba #1 moves up!\n\nAmoeba #1 -- Position: [-1, -2], Energy: 2\nAmoeba #1 moves left!\n\nAmoeba #1 -- Position: [-2, -2], Energy: 1\nAmoeba #1 moves up!\n\nAmoeba #1 -- Position: [-2, -1], Energy: 0\nAmoeba #1 is too weak to move!\n\n\n\n\nAside: Refactoring the Amoeba Class\nAfter building our Amoeba class, we can see that some functionality, specifically position tracking and movement, isn’t necessarily Amoeba-specific. We’re currently using a two-element list for position and updating it within the Amoeba’s move method. While this works for our small class, let’s extract this common behavior into a dedicated Position class.\n\nclass Position:\n    \"\"\"\n    Represents a position in 2D space.\n\n    This class handles tracking and updating a position in a 2D grid system,\n    with methods for moving in cardinal directions.\n\n    Attributes:\n        x (int): The x-coordinate\n        y (int): The y-coordinate\n    \"\"\"\n\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def __str__(self):\n        return f\"({self.x}, {self.y})\"\n\n    def move_right(self):\n        \"\"\"Move one unit to the right (increase x).\"\"\"\n        self.x += 1\n\n    def move_left(self):\n        \"\"\"Move one unit to the left (decrease x).\"\"\"\n        self.x -= 1\n\n    def move_up(self):\n        \"\"\"Move one unit up (increase y).\"\"\"\n        self.y += 1\n\n    def move_down(self):\n        \"\"\"Move one unit down (decrease y).\"\"\"\n        self.y -= 1\n\nNow that we have the Position class, we can use it in the Amoeba class instead of the original two-element list. In this way, the Amoeba class delegates the behavior of position and movement to the Position class rather than manage that itself.\n\nclass Amoeba:\n    \"\"\"\n    Represent an amoeba with position and energy tracking.\n\n    This class models an amoeba that can move around in a 2D space and manage\n    its energy levels. Each amoeba has a unique ID, position coordinates, and\n    energy value.\n\n    Attributes:\n        counter (int): Class variable that keeps track of how many amoeba instances\n            have been created.\n        id (str): Unique identifier for each amoeba instance.\n        position (Position): A Position object representing the amoeba's location.\n        energy (int): Current energy level of the amoeba.\n    \"\"\"\n\n    counter = 0\n\n    def __init__(self, position=None, energy=5):\n        Amoeba.counter += 1\n        self.id = f\"Amoeba #{Amoeba.counter}\"\n\n        if position is None:\n            self.position = Position()\n        else:\n            self.position = position\n\n        self.energy = energy\n\n    def __str__(self):\n        return f\"{self.id} -- Position: {self.position}, Energy: {self.energy}\"\n\n    def move(self, direction):\n        \"\"\"Move the amoeba, consuming energy.\"\"\"\n\n        if self.energy &lt;= 0:\n            print(f\"{self.id} is too weak to move!\")\n            return\n\n        if direction == \"right\":\n            print(f\"{self.id} moves right!\")\n            self.position.move_right()\n        elif direction == \"left\":\n            print(f\"{self.id} moves left!\")\n            self.position.move_left()\n        elif direction == \"up\":\n            print(f\"{self.id} moves up!\")\n            self.position.move_up()\n        elif direction == \"down\":\n            print(f\"{self.id} moves down!\")\n            self.position.move_down()\n        else:\n            raise ValueError(\"direction must one of up, down, left, or right\")\n\n        self.energy -= 1\n\n    def eat(self):\n        \"\"\"The amoeba eats, increasing its energy.\"\"\"\n        self.energy += 1\n\nThere’s a new syntax element to note: self.position.move_right(). This expression chains multiple “dots” to connect attributes and method calls, something you’ll see frequently in Python. You can read it left to right like this:\n\n\n\nA schematic of chained method calls\n\n\nExtracting the Position class from the Amoeba class brings a couple of nice benefits:\n\nSeparation of concerns: Each class now has a single responsibility\nReusability\n\nThe Position class could now be used for other entities that need position tracking.\nIf we need to change how positions work, we only need to change one place rather than in every class that need position tracking.\n\nEncapsulation: Position management details are hidden inside the Position class\n\nThis process is called a refactoring, and in this case, we have shown how to spot shared functionality and extract it into a separate class. While this is a good skill to have in your toolkit, don’t feel that you have to separate everything. Sometimes it’s overkill, especially for one-off scripts or when code reuse is unlikely. Use your judgment!\n\n\nSpecial Methods\nSpecial methods (like __init__ and __str__) let your custom classes work with Python’s built-in operations. These “magic methods” act as interfaces between your code and core Python functionality. Though they have a cool name, these methods aren’t mysterious, rather, they’re like standardized hooks that let your classes interact more easily with Python’s built-in functions.\nFor example, when Python performs certain operations, it looks for certain methods:\n\nWhen using the + operator, Python looks for the __add__ method\nWhen using the len() function, Python looks for the __len__ method\nWhen initializing an object, Python looks for the __init__ method\nWhen printing an object, Python looks for the __str__ method\n\nBy implementing these methods, your custom objects can behave like Python’s native types. For example, a DNA sequence class with __add__ could allow sequence concatenation using the simple + operator, just like with strings.\nIn the Amoeba and Position classes, we implemented __str__. The __str__ method is called whenever Python needs a human-readable string representation of your object, such as when you use the print() function.\nThe __str__ method should return a concise, informative string that gives the user meaningful information about the object. If you don’t define a __str__ method for your class, Python will use a default representation. Compare the output when printing an Amoeba instance versus when printing a BlueJay instance:\n\nprint(Amoeba())\nprint(BlueJay())\n\nAmoeba #1 -- Position: (0, 0), Energy: 5\n&lt;__main__.BlueJay object at 0x110efa650&gt;\n\n\nSince we didn’t explicitly define a __str__ method for the BlueJay class, Python prints a default representation of the object, rather than a nice, informative message.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "chapters/05_classes.html#duck-typing",
    "href": "chapters/05_classes.html#duck-typing",
    "title": "5  Introduction to Object-Oriented Programming",
    "section": "Duck Typing",
    "text": "Duck Typing\nThe duck test goes something like this:\n\nIf it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck!\n\nMany programming languages, including Python, use this idea for something we call duck typing. In this context, Python is essentially saying, “Well, I don’t know what class this object is, but if it can swim or fly or quack, then I will treat it like a Duck.” In other words, it only cares whether the object can perform the needed actions. If it can, then Python will happily work with it regardless of what it actually is. This practical approach represents one way Python implements the polymorphism pillar of OOP mentioned earlier.\nLet’s see an example of this in action:\n\nclass Duck:\n    def quack(self):\n        print(\"quack, QUACK!!\")\n\n    def fly(self):\n        print(\"the duck is flying!\")\n\n    def swim(self):\n        print(\"the duck is swimming\")\n\n\nclass Gull:\n    def squawk(self):\n        print(\"squawk!!!\")\n\n    def fly(self):\n        print(\"the crow flies!\")\n\n    def swim(self):\n        print(\"the gull swims near the beach\")\n\n\nclass Whale:\n    def swim(self):\n        print(\"the whale is swims underwater\")\n\nAll three of these classes have a method called swim. If we have a collection of those objects, we can call the swim method on each of them without having to know what type the object is:\n\nanimals = [Duck(), Duck(), Gull(), Whale()]\n\nfor animal in animals:\n    animal.swim()\n\nthe duck is swimming\nthe duck is swimming\nthe gull swims near the beach\nthe whale is swims underwater\n\n\nWhile convenient, you might not always know if your objects have the method you need. There are two common ways to deal with this:\n\nSimply call the method and catch any exceptions that occur. (the Python docs call this EAFP style programming – “Easier to ask for forgiveness than permission”)\nCheck if the object has the method before attempting to call it. (the Python docs call this LBYL style programming – “look before you leap”)\n\nBoth approaches have their place, depending on your specific situation and coding style preferences. Let’s look at examples of both approaches.\n\nAsking for Forgiveness\nIn this example, we call the method fly on each animal and catch any exceptions that occur using try/except.\n\nanimals = [Duck(), Duck(), Gull(), Whale()]\n\nfor animal in animals:\n    try:\n        animal.fly()\n    except AttributeError as error:\n        print(error)\n\nthe duck is flying!\nthe duck is flying!\nthe crow flies!\n'Whale' object has no attribute 'fly'\n\n\n\n\nLooking Before You Leap\nIn this example, we use hasattr (short for “has attribute”) to check if each animal has the fly attribute before attempting to call the method.\n\nanimals = [Duck(), Duck(), Gull(), Whale()]\n\nfor animal in animals:\n    if hasattr(animal, \"fly\"):\n        animal.fly()\n    else:\n        print(f\"{animal} can't fly!\")\n\nthe duck is flying!\nthe duck is flying!\nthe crow flies!\n&lt;__main__.Whale object at 0x108248050&gt; can't fly!\n\n\n\n\nSpecial Methods & Duck Typing\nLet’s return once more to Python’s special “magic methods”. These are a great example of how duck typing can be useful. If we implement special methods like __str__ or __len__ for our custom classes, then Python can treat them like built-ins. Here’s an example of a Gene class:\n\nclass Gene:\n    def __init__(self, name, sequence):\n        self.name = name\n        self.sequence = sequence\n\n    # Special method for string representation\n    def __str__(self):\n        return f\"&gt;{self.name}\\n{self.sequence}\"\n\n    # Special method for length\n    def __len__(self):\n        return len(self.sequence)\n\n\ngene = Gene(\"awesome_gene\", \"ATGATATCCATCGCTACTAGACTACTACGCGCGGCTCT\")\n\nprint(len(gene))\nprint(gene)\n\n38\n&gt;awesome_gene\nATGATATCCATCGCTACTAGACTACTACGCGCGGCTCT\n\n\nIn this example, our __str__ method formats the gene to match FASTA file conventions, while the length method returns the sequence length. These additions help our Gene class behave more like native Python objects, seamlessly integrating with the language’s expectations.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "chapters/05_classes.html#standard-python-classes",
    "href": "chapters/05_classes.html#standard-python-classes",
    "title": "5  Introduction to Object-Oriented Programming",
    "section": "Standard Python Classes",
    "text": "Standard Python Classes\nIn Chapter 2, we introduced built-in Python data structures like lists, dictionaries, and sets. Now we can recognize these as classes that follow the principles we’ve just learned: they combine data and behavior into objects with methods that help us work with them safely and effectively.\nLet’s look at a few examples of how built-in Python classes provide methods that operate on their internal data:\n\n# List methods\nmy_list = [1, 2, 3, 4]\n\n# Adds an element to the end\nmy_list.append(5)\n\n# Reverses the list in-place\nmy_list.reverse()\n\nprint(my_list)\n\n# String methods\ntext = \"  hello world  \"\n\n# Strip whitespace\nprint(text.strip())\n\n# Strip whitespace, then uppercase\nprint(text.strip().upper())\n\n# Strip whitespace, then uppercase, then replace capital L with lowercase l\nprint(text.strip().upper().replace(\"L\", \"l\"))\n\n\ngene_info = {\"name\": \"some_gene\", \"chromosome\": 10}\n\n# Print the keys\nprint(gene_info.keys())\n\n# \"Merge\" the dictionaries\ngene_info.update({\"function\": \"tumor suppressor\"})\n\nprint(gene_info)\n\n[5, 4, 3, 2, 1]\nhello world\nHELLO WORLD\nHEllO WORlD\ndict_keys(['name', 'chromosome'])\n{'name': 'some_gene', 'chromosome': 10, 'function': 'tumor suppressor'}\n\n\nOther commonly used built-in classes include:\n\nset – for handling collections of unique items\nfile objects – returned when opening files with the open() function\ndatetime – for working with dates and times\n\nEach of these classes encapsulates both data (like the items in a list) and behavior (methods like append or sort), just like the custom classes we wrote in this tutorial.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "chapters/05_classes.html#object-oriented-thinking",
    "href": "chapters/05_classes.html#object-oriented-thinking",
    "title": "5  Introduction to Object-Oriented Programming",
    "section": "Object-Oriented Thinking",
    "text": "Object-Oriented Thinking\nNow that you have seen the mechanics of building and using classes in Python, let’s get a little meta. When thinking in an object-oriented way, you see your system in terms interacting entities – an approach that fits naturally with how we like to think about biological systems. Here’s a quick guide to developing an object-oriented mindset:\n\nIdentify key entities\n\nWhat are your main working pieces?\nPhysical things like cells, proteins, genes, patients?\nAbstract concepts like Files, Queues, Nodes, Graphs?\n\nDetermine their properties\n\nWhat characteristics define them?\nExample: cells have size, type, metabolic rate\n\nIdentify their actions\n\nWhat can they do?\nCells divide, proteins fold, birds fly, files can be read\n\nGroup related functionality: cell properties and behaviors belong in a Cell class\nSplit classes when they become unwieldy or overly complex\n\nStart with these steps as your foundation. As you gain experience, you’ll naturally develop a feel for modeling systems that works best for your specific projects.\n\nBalancing Approaches\nPython’s flexibility lets you mix programming approaches within a single project or script.\nGood Python code often combines different paradigms:\n\nObject-oriented for modeling biological entities where data and behavior are linked\nFunctional for data transformations and analysis\nProcedural for simple sequential operations\n\nLet the problem you’re tyring to solve guide your programming approach. Sometimes a simple module with functions works better than a class, while other times a well-designed class hierarchy models your domain in the clearest way.\nIn general, classes work well when you’re working with entities that have both data (attributes) and behaviors (methods) that naturally belong together. Consider using classes when:\n\nYou need multiple similar entities with shared structure and behavior (like 1000 cells in a simulation)\nYou repeatedly apply the same operations to specific data types\nYour data needs validation (ensuring DNA sequences only contain valid nucleotides)\nData and actions are tightly coupled\nYou need to track state across operations\nYour project needs additional structure\nYour data has natural hierarchies (DNA and Proteins are both Molecules)\n\nNote: We didn’t get into class hierarchies in this tutorial. That’s an advanced topic for a later time.\nConsider simpler alternatives when:\n\nWriting straightforward data processing scripts\nDealing with mostly static data\nUsing functions that transform data without maintaining state\nWorking with data where built-in Python structures are sufficient\nYour project is small and classes would add unnecessary complexity\n\nMany popular data science libraries like pandas and seaborn emphasize data transformations and function chaining rather than object-oriented approaches. When using these libraries, follow their patterns instead of forcing objects where they don’t make sense.\nThe goal is clear, maintainable code that you and colleagues understand. Start simple, adding complexity only when needed. With experience, you’ll develop intuition for when classes are the right tool.\n\n\nGeneral Tips and Pitfalls\nLet’s wrap up with some broad best practices and common pitfalls for working with classes. We’ll refine these as you tackle more complex programs throughout the course.\nGeneral tips:\n\nFollow naming conventions\n\nPascalCase for classes (BacterialCell), snake_case for methods/attributes (growth_rate)\n\nKeep classes focused\n\nOne clear purpose per class\nAvoid mixing responsibilities\n\nDesign intuitive interfaces\n\nConsider how others will interact with your classes\nMake correct usage easy, incorrect usage difficult\n\nDocument with docstrings\nValidate inputs in __init__\nImplement magic methods when appropriate\n\nGeneral pitfalls:\n\nModeling excessive behavior\n\nInclude only what’s relevant to your specific application\nA bird has many attributes, but you only need what serves your research question\n\nOverloaded classes\n\nA Cell class shouldn’t also process sequencing data and generate plots\n\nUnderutilized classes\n\nData-only classes might work better as dictionaries\nMethod-only classes might work better as function modules\n\nPoor naming choices\n\nclass Gene communicates purpose better than class X",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "chapters/05_classes.html#wrap-up",
    "href": "chapters/05_classes.html#wrap-up",
    "title": "5  Introduction to Object-Oriented Programming",
    "section": "Wrap-Up",
    "text": "Wrap-Up\nPython classes create custom data types that bundle related data and functions together, helping organize code by grouping attributes and methods. In scientific programming, they’re great for representing complex entities with intertwined data and behavior. Use classes when they make your code more organized and readable – with experience, you’ll develop instincts for when to use them versus simpler approaches. Keep exploring, stay curious, and experiment with different solutions to your scientific problems!",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "chapters/05_classes.html#suggested-readings",
    "href": "chapters/05_classes.html#suggested-readings",
    "title": "5  Introduction to Object-Oriented Programming",
    "section": "Suggested Readings",
    "text": "Suggested Readings\nYou might enjoy checking out some of these resources:\n\nPython Docs: Classes\nReal Python\n\nObject-Oriented Programming (OOP) in Python\nPython Class Constructors: Control Your Object Instantiation\nClass and Instance Attributes\nDuck Typing in Python: Writing Flexible and Decoupled Code\n\nWikipedia’s Object-oriented programming",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Introduction to Object-Oriented Programming</span>"
    ]
  },
  {
    "objectID": "chapters/06_errors.html",
    "href": "chapters/06_errors.html",
    "title": "6  Errors & Exceptions",
    "section": "",
    "text": "Syntax Errors\nErrors and unexpected situations happen in nearly all programs, even simple ones. It’s important to understand that errors are a normal part of programming, and there are good techniques to help us write code that can handle common errors effectively.\nThis chapter explores errors and exceptions and how to manage them in your Python code. We’ll begin with basic errors like syntax mistakes (similar to grammar errors in writing) or mathematical issues like dividing by zero. Then we’ll progress to more advanced techniques that help your programs handle unexpected situations gracefully.\nThroughout this guide, you’ll see practical examples that show how to:\nBy the end, you’ll feel more confident writing code that can recover from problems rather than crashing when something unexpected happens. This skill is essential for creating robust and reliable programs.\nSyntax errors are problems that happen when you write Python code that breaks the language’s grammar rules. These errors are very common when you’re first learning Python because you’re still getting used to how Python code should be structured. Here is an example of a syntax error:\nIf you run this Python code, you would get an error message like this:\nAs you can see, I forgot to put the colon (:) at the end of the first line. This is a classic syntax mistake in Python, similar to forgetting a period at the end of a sentence.\nRemember in previous tutorials and assignments, like when we discussed removing items from dictionaries (Section 2.6.2.3), scope (Section 4.5), and the “ask for forgiveness” approach (Section 5.6.1), we used try/except blocks to “catch” errors. However, syntax errors cannot be caught using try/except. This is because the Python interpreter checks your code’s syntax before running any of it. The syntax error is detected during this checking phase, before your program even starts executing, so the try/except block never gets a chance to run.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errors & Exceptions</span>"
    ]
  },
  {
    "objectID": "chapters/06_errors.html#syntax-errors",
    "href": "chapters/06_errors.html#syntax-errors",
    "title": "6  Errors & Exceptions",
    "section": "",
    "text": "for i in range(10)\n    print(i)\n\nfor i in range(10)\n                  ^\nSyntaxError: expected ':'",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errors & Exceptions</span>"
    ]
  },
  {
    "objectID": "chapters/06_errors.html#understanding-python-exceptions",
    "href": "chapters/06_errors.html#understanding-python-exceptions",
    "title": "6  Errors & Exceptions",
    "section": "Understanding Python Exceptions",
    "text": "Understanding Python Exceptions\nErrors can still appear in your code even when the syntax is correct. In Python, these runtime errors are called exceptions. If an exception happens and you don’t address it in your code, your program will crash and stop running.\n\nCommon Exceptions\nThere are many different exceptions in Python. Let’s start with two simple ones: NameError and TypeError.\n\nName Errors\nA NameError occurs when Python can’t find a name you’re trying to use. This typically happens when you try to use a variable or function that doesn’t exist or hasn’t been defined yet.\nx = 1 + y\nIf you ran this code in the Python interpreter or from a program, you would see an error message like this:\nNameError             Traceback (most recent call last)\nFile 06_errors.qmd:1\n----&gt; 1 x = 1 + y\n\nNameError: name 'y' is not defined\nThis error message shows the type of error, the file where it happened, and a helpful explanation of the problem. We will go into more detail about reading error messages later in this tutorial.\n\n\nType Errors\nA TypeError happens when you try to perform an operation on a data type that doesn’t support that operation. (It’s sort of like trying to use a lab technique on the wrong type of sample.)\n47 + \"102\"\nRunning this code produces the following error:\nTypeError              Traceback (most recent call last)\nFile 06_errors.qmd:1\n----&gt; 1 47 + \"102\"\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\nThis message tells you that Python doesn’t allow you to add an integer and a string together.\n\n\nOther Common Exceptions\nSome other exceptions you might encounter include:\n\nIndexError: When you try to access a position beyond the end of a list or string (like trying to access the 5th nucleotide in a 3-nucleotide codon)\nFileNotFoundError: When Python can’t find the file or directory you’re trying to access\nKeyError: When you try to access a key that doesn’t exist in a dictionary (similar to looking up a gene ID that isn’t in your database)\nAttributeError: When you try to access features or properties that don’t exist for a particular object\nValueError: When you provide the right type of value but with incorrect content, such as:\n\nTrying to use a square root transformation on a sample with a negative value (math.sqrt(-1))\nTrying to convert na expression values (float(\"na\"))\n\n\nFor a complete list of Python exceptions, see the Built-in Exceptions section of the Python manual.\n\n\n\nReading Error Messages\nOne challenge many beginners face is understanding error messages, both how to interpret them and how to fix the problems they indicate.\nAs a new programmer, you’ll likely encounter different types of errors than experienced programmers do. You’ll often see syntax errors or errors from misusing Python’s language features or misunderstanding how functions and classes work. This can be particularly frustrating because these aren’t errors you might anticipate. While you might have expected a user-provided file name might not exist, you probably would not have anticipated using a built-in function incorrectly!\nLearning to read error messages is an essential skill for your programming journey. In Python, error messages typically contain:\n\nError type: The kind of error that occurred (e.g., RuntimeError)\nTraceback: The sequence of function calls that led to the error\nFile location: Where the error occurred (file name and line number)\nArrow pointer: Points to the specific part of code causing the error\nError message: A description of what went wrong\n\nLet’s examine a few error messages to better understand their structure and meaning. We will start with a simple example:\ndef wibble():\n    raise RuntimeError(\"oh no!!\")\n\n\ndef wobble():\n    wibble()\n\n\ndef woo():\n    wobble()\n\n\nwoo()\nIf you ran this code in a Quarto notebook, you would get an error that looks like this:\nRuntimeError              Traceback (most recent call last)\nCell In[2], line 13\n      9 def woo():\n     10     wobble()\n---&gt; 13 woo()\n\nCell In[2], line 10, in woo()\n      9 def woo():\n---&gt; 10     wobble()\n\nCell In[2], line 6, in wobble()\n      5 def wobble():\n----&gt; 6     wibble()\n\nCell In[2], line 2, in wibble()\n      1 def wibble():\n----&gt; 2     raise RuntimeError(\"oh no!!\")\n\nRuntimeError: oh no!!\nIn this example, the process went like this:\n\nFirst, the program called woo()\nThen, inside woo(), it called wobble()\nNext, inside wobble(), it called wibble()\nFinally, inside wibble(), a RuntimeError occurred\n\nYou can read the traceback in two ways:\nTop-to-bottom (the order the code executed):\n\nOn line 13, woo() is called\nOn line 10, in woo, wobble() is called\nOn line 6, in wobble, wibble() is called\nOn line 2, in wibble, raise RuntimeError is called, which crashes the program\n\nBottom-to-top (starting with the actual error):\n\nOn line 2, in wibble, raise RuntimeError is called, which crashes the program\nOn line 6, in wobble, wibble() is called\nOn line 10, in woo, wobble() is called\nOn line 13, woo() is called\n\nExamining error tracebacks in both directions will often help you better understand what went wrong in your code.\nLet’s look another example:\ndef parse_line(line):\n    gene, sample, expression = line.strip().split(\",\")\n\n    return (gene, sample, float(expression))\n\n\ndef read_expression_data(filename):\n    with open(filename) as f:\n        for line in f:\n            gene, sample, expression = parse_line(line)\n            print(f\"{gene}-{sample} =&gt; {expression}\")\n\n\nread_expression_data(\"expression_data.csv\")\nPretend there is a file called expression_data.csv that has the following contents:\ngene1,sample1,25\ngene1,sample2,50\ngene2,sample1,na\ngene2,sample2,15\nLet’s assume that you have saved that code in a script called example.py. When you run it you would see output that looks something like this:\ngene1-sample1 =&gt; 25.0\ngene1-sample2 =&gt; 50.0\nTraceback (most recent call last):\n  File \"example.py\", line 14, in &lt;module&gt;\n    read_expression_data(\"expression_data.csv\")\n    ~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^\n  File \"example.py\", line 10, in read_expression_data\n    gene, sample, expression = parse_line(line)\n                               ~~~~~~~~~~^^^^^^\n  File \"example.py\", line 4, in parse_line\n    return (gene, sample, float(expression))\n                          ~~~~~^^^^^^^^^^^^\nValueError: could not convert string to float: 'na'\nLet’s break it down:\nThe script processes gene expression data from a CSV file. It runs smoothly for the first two lines of the file, but crashes when it encounters \"na\" in the third line. The error happens because Python’s float() function cannot convert the text \"na\" (which stands for “not available” in biological data) into a floating-point number.\nThe error message shows us the exact path of execution that led to the problem. It starts at line 14 where we call read_expression_data(), then moves to line 10 where we call parse_line(), and finally reaches line 4 where the actual error occurs when trying to convert \"na\" to a float.\nThis is a common issue when working with biological datasets, which often contain missing values represented as “na”, “N/A”, or similar placeholders. To fix this problem, we would need to add error handling when running the float function, or use some other technique to check for these special values before attempting the conversion.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errors & Exceptions</span>"
    ]
  },
  {
    "objectID": "chapters/06_errors.html#basic-exception-handling",
    "href": "chapters/06_errors.html#basic-exception-handling",
    "title": "6  Errors & Exceptions",
    "section": "Basic Exception Handling",
    "text": "Basic Exception Handling\nNow that we’ve discussed what exceptions are, let’s explore how we can recover from them and prevent unexpected errors from crashing our programs.\nThe basic format uses try: followed by an indented block of code, then except SomeError:, followed by another indented block of code:\n\ntry:\n    47 + \"102\"\nexcept TypeError as error:\n    print(f\"an type error occurred: {error=}\")\n\nan type error occurred: error=TypeError(\"unsupported operand type(s) for +: 'int' and 'str'\")\n\n\nLet’s break this down:\n\nThe “try clause” contains the code that might cause an error.\n\nIt is placed between the try and except keywords.\nHere, our try clause has just one expression: 47 + \"102\"\n\nThe “except clause” contains the code that runs if an error occurs.\n\nIt is placed after the except keyword and continues until the indentation ends.\n\nexcept TypeError as error:\n\nTypeError specifies which kind of error we want to catch\nIf a TypeError happens, Python saves the error information in the variable named error so we can use it\n\nprint(f\"a TypeError occurred: {error}\") is the code that runs when a TypeError occurs in the try clause\n\nThe try/except statement is a bit like a safety net for your code: you’re trying something that might fail (the try clause), but you’ve prepared a backup plan (the except clause) just in case.\nNext, let’s see how Python runs through this type of code.\n\nTry/Except Code Flow\nPython follows a specific process when it encounters a try/except block. First, it attempts to run all the code inside the “try clause.” If this code runs without any problems, Python simply skips the except clause and continues with the rest of your program.\nHowever, if an error occurs while running the try clause, Python immediately stops executing that section. It then checks if the error type matches what you specified after the except keyword. For instance, if you wrote except TypeError:, Python looks specifically for TypeErrors.\nIf the error matches what you specified, Python runs the code in the except clause and then continues with the rest of your program.\nIf the error doesn’t match what you specified, Python considers it an “unhandled exception”. In this case, your program will stop running and display an error message.\nThis might sound a bit abstract, so let’s go through some examples to see how it works step by step.\n\nNo Exception in the Try Clause\nIn this example, no exception occurs in the try clause.\n\ntry:\n    print(\"hi\")\nexcept TypeError as error:\n    print(f\"an error occurred: {error=}\")\n\nprint(\"yo!\")\n\nhi\nyo!\n\n\n\nPython runs the contents of the try clause: print(\"hi\")\nprint(\"hi\") runs without error and displays “hi” on the screen\nSince no error occurred, Python skips the except clause completely\nPython continues to the next line and runs print(\"yo!\")\n\n\n\nException in the Try Clause\nIn this example, an error occurs that matches the one in our except clause:\n\ntry:\n    print(greeting)\nexcept NameError as error:\n    print(f\"an error occurred: {error=}\")\n\nprint(\"yo!\")\n\nan error occurred: error=NameError(\"name 'greeting' is not defined\")\nyo!\n\n\n\nPython runs the contents of the try clause: print(greeting)\nprint(greeting) causes a NameError because greeting hasn’t been defined (you must define variables before using them)\nSince a NameError occurred and we specifically included NameError in our except statement, Python executes the except block: print(f\"an error occurred: {error=}\")\nAfter completing the try/except block, Python continues to the next line and runs print(\"yo!\")\n\n\n\nNon-Matching Exception in the Try Clause\nThis example shows what happens when the error that occurs is different from the one we’re trying to catch:\ntry:\n    47 + \"102\"\nexcept NameError as error:\n    print(f\"an error occurred: {error=}\")\n\nprint(\"yo!\")\n\nPython runs the contents of the try clause: 47 + \"102\"\n47 + \"102\" causes a TypeError because Python can’t add a number to text\nPython checks if TypeError matches what we’re catching in our except statement, but we’re only catching NameError\nSince the error types don’t match and there are no other try statements, the error remains uncaught\nThe program crashes with an error message and stops running\nprint(\"yo!\") never runs because the program already crashed\n\n\n\n\nCatching Multiple Exceptions\nYou can catch different types of exceptions within a single try/except block by adding multiple except clauses. When an error occurs in the try block, Python looks for a matching except block to handle that specific error type. Once it finds a match, it runs that code and then continues with the rest of your program. If no match is found, then the program crashes.\nFor example, if your code causes a NameError (like using a variable that doesn’t exist), only the except clause that handles NameError will run. The other except clauses, like one for TypeError, will be skipped:\n\ntry:\n    print(greeting)\nexcept NameError as name_error:\n    print(f\"a NameError occurred: {name_error=}\")\nexcept TypeError as type_error:\n    print(f\"a TypeError occurred: {type_error=}\")\n\na NameError occurred: name_error=NameError(\"name 'greeting' is not defined\")\n\n\nIn this case, it is the opposite – the code in the try clause causes a TypeError, causing only the expect clause handling type errors to run:\n\ntry:\n    47 + \"102\"\nexcept NameError as name_error:\n    print(f\"a NameError occurred: {name_error}\")\nexcept TypeError as type_error:\n    print(f\"a TypeError occurred: {type_error}\")\n\na TypeError occurred: unsupported operand type(s) for +: 'int' and 'str'\n\n\nSometimes you might want to handle different errors in the same way. In these cases, you can group multiple exceptions in a single except clause:\n\ntry:\n    print(greeting)\nexcept (NameError, TypeError) as error:\n    print(f\"an error occurred: {error=}\")\n\ntry:\n    47 + \"102\"\nexcept (NameError, TypeError) as error:\n    print(f\"an error occurred: {error=}\")\n\nan error occurred: error=NameError(\"name 'greeting' is not defined\")\nan error occurred: error=TypeError(\"unsupported operand type(s) for +: 'int' and 'str'\")\n\n\n\n\nClauses Can Contain Multiple Statements\nEach section (clause) in a try/except block can include multiple lines of code:\n\ntry:\n    # This line will run successfully\n    print(1 + 2)\n\n    # This line will cause a TypeError (mixing number and text)\n    print(10 + \"20\")\n\n    # This line will never execute because the error above stops the try block\n    print(100 + 200)\nexcept TypeError as error:\n    # This line runs because we caught a TypeError from above\n    print(f\"an error occurred: {error=}\")\n\n    # This line also runs since all code in the except clause executes\n    # (unless another error happens)\n    print(\"this will also run!\")\n\n3\nan error occurred: error=TypeError(\"unsupported operand type(s) for +: 'int' and 'str'\")\nthis will also run!\n\n\nNote: We’ll discuss this more later, but it’s generally best practice to keep the code in each clause short and simple, with as few statements as possible.\n\n\nExceptions Can Happen in the Except Block\nOne important thing to remember is that exceptions can also occur in your except block code:\ntry:\n    # This line will run\n    print(1 + 2)\n\n    # This line will raise the TypeError\n    print(10 + \"20\")\n\n    # This line will not run because the previous line caused a TypeError\n    print(100 + 200)\nexcept TypeError as error:\n    # This line will run because a TypeError occurred in the above clause\n    print(f\"an occurred: {error=}\")\n\n    # This line will raise a NameError since the name `twenty` has not been\n    # defined\n    print(10 + twenty)\n\n    # This line will not run because the above line raises another exception!\n    print(\"this will also run!\")\nIf you ran this code, you would see output like this:\nTypeError                                 Traceback (most recent call last)\nCell In[1], line 6\n      5 # This line will raise the TypeError\n----&gt; 6 print(10 + \"20\")\n      8 # This line will not run because the previous line caused a TypeError\n\nTypeError: unsupported operand type(s) for +: 'int' and 'str'\n\nDuring handling of the above exception, another exception occurred:\n\nNameError                                 Traceback (most recent call last)\nCell In[1], line 16\n     12 print(f\"an occurred: {error=}\")\n     14 # This line will raise a NameError since the name `twenty` has not been\n     15 # defined\n---&gt; 16 print(10 + twenty)\n     18 # This line will not run because the above line raises another exception!\n     19 print(\"this will also run!\")\n\nNameError: name 'twenty' is not defined\nNotice the key message: “During handling of the above exception, another exception occurred”. This tells us what happened. While the program was trying to recover from one error, it encountered a second error. Since there was no error handler set up for this second error, the program crashed.\nFor more information about this concept, check out the Python documentation on exception chaining.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errors & Exceptions</span>"
    ]
  },
  {
    "objectID": "chapters/06_errors.html#advanced-exception-handling",
    "href": "chapters/06_errors.html#advanced-exception-handling",
    "title": "6  Errors & Exceptions",
    "section": "Advanced Exception Handling",
    "text": "Advanced Exception Handling\nLet’s explore some more advanced ways to handle exceptions in Python. While you might not need to use these techniques in your current assignments and miniprojects, it’s still valuable to understand them. You’ll encounter these patterns when reading other people’s code or working with existing Python libraries and tools.\n\nException Hierarchies\nPython exceptions form a hierarchy, and are organized a bit like a family tree. Here’s a simplified view of this hierarchy:\nBaseException\n └── Exception\n      ├── ArithmeticError\n      │    ├── FloatingPointError\n      │    ├── OverflowError\n      │    └── ZeroDivisionError\n      ├── RuntimeError\n      │    ├── NotImplementedError\n      │    ├── PythonFinalizationError\n      │    └── RecursionError\nTo understand this relationship:\n\nA ZeroDivisionError is a type of ArithmeticError\nAn ArithmeticError is a type of Exception\nAn Exception is a type of BaseException\n\nThis is similar to how taxonomic relationships work. Just as a cat is a feline, all felines are mammals, and all mammals are animals, a ZeroDivisionError is an ArithmeticError, all ArithmeticErrors are Exceptions, and all Exceptions are BaseExceptions.\nNote that a ZeroDivisionError is an ArithmeticError, but it is not a RuntimeError – similar to how cats and dogs are both mammals, but a cat is not a canine.\nThe complete exception hierarchy is is available in the Python documentation.\nThe benefit of this hierarchy is that we can catch a whole group of related errors without listing each one individually. Here’s a simple example with a function that performs basic math operations:\n\nimport math\n\ndef silly_math(x, y):\n    math.exp(x) / y\n\nThis function can raise several different errors:\n\nIf y is 0, we get a ZeroDivisionError\nIf x is too large, we get an OverflowError\nIf x or y aren’t numbers, we get a TypeError\n\nImagine we’re reading the values of x and y from a data file, so we don’t know what they’ll be until the program runs. We can handle potential errors like this:\n\n# ZeroDivisionError\ntry:\n    x = 1\n    y = 0\n    silly_math(x, y)\nexcept (ZeroDivisionError, OverflowError) as error:\n    print(f\"there was an arithmetic error! {error=}\")\nexcept TypeError as error:\n    print(f\"one of the values wasn't numeric! {error=}\")\n\n\n# OverflowError\ntry:\n    x = 1000\n    y = 2\n    silly_math(x, y)\nexcept (ZeroDivisionError, OverflowError) as error:\n    print(f\"there was an arithmetic error! {error=}\")\nexcept TypeError as error:\n    print(f\"one of the values wasn't numeric! {error=}\")\n\n\n# TypeError\ntry:\n    x = 1\n    y = \"2\"\n    silly_math(x, y)\nexcept (ZeroDivisionError, OverflowError) as error:\n    print(f\"there was an arithmetic error! {error=}\")\nexcept TypeError as error:\n    print(f\"one of the values wasn't numeric! {error=}\")\n\nthere was an arithmetic error! error=ZeroDivisionError('float division by zero')\nthere was an arithmetic error! error=OverflowError('math range error')\none of the values wasn't numeric! error=TypeError(\"unsupported operand type(s) for /: 'float' and 'str'\")\n\n\nThis works, but we can simplify by using the parent class ArithmeticError instead:\n\n# ZeroDivisionError\ntry:\n    x = 1\n    y = 0\n    silly_math(x, y)\nexcept ArithmeticError as error:\n    print(f\"there was an arithmetic error! {error=}\")\nexcept TypeError as error:\n    print(f\"one of the values wasn't numeric! {error=}\")\n\n\n# OverflowError\ntry:\n    x = 1000\n    y = 2\n    silly_math(x, y)\nexcept ArithmeticError as error:\n    print(f\"there was an arithmetic error! {error=}\")\nexcept TypeError as error:\n    print(f\"one of the values wasn't numeric! {error=}\")\n\nthere was an arithmetic error! error=ZeroDivisionError('float division by zero')\nthere was an arithmetic error! error=OverflowError('math range error')\n\n\nBoth ZeroDivisionError and OverflowError are caught by the ArithmeticError handler because they are both types of ArithmeticError.\nHowever, it’s important to understand that this doesn’t work in reverse. Let’s see what happens if we try to catch an ArithmeticError with a ZeroDivisionError handler:\ntry:\n    # This code cause a specific error, in this case an ArithmeticError,\n    # to happen\n    raise ArithmeticError(\"oops!\")\nexcept ZeroDivisionError:\n    print(\"this won't catch the ArithmeticError\")\nHere is the error message:\nArithmeticError                  Traceback (most recent call last)\nCell In[1], line 2\n      1 try:\n----&gt; 2     raise ArithmeticError(\"oops!\")\n      3 except ZeroDivisionError:\n      4     print(\"this won't catch the ArithmeticError\")\n\nArithmeticError: oops!\nThis is because while every ZeroDivisionError is an ArithmeticError, every ArithmeticError is not a ZeroDivisionError.\nNote: check out the raise statement for more about manually raising exceptions.\nYou may have noticed that this connects back to the Object-Oriented Programming concepts we discussed in Section 5.1. This error class hierarchy shows inheritance at work: exception classes inherit from their parent exception classes. When we catch an ArithmeticError, we’re using this inheritance relationship to handle any type of exception that belongs to that family. This is a practical example of why inheritance is useful in programming.\n\n\nNesting Try/Except Blocks\nIt can sometimes be useful to nest try/except blocks. This is like having backup plans for your backup plans!\nThe first example shows how Python searches for an appropriate error handler. If an inner error handler doesn’t match the exception type, Python will check outer handlers:\n\ntry:\n    try:\n        raise TypeError(\"oh no!\")\n    except NameError:\n        print(\"this won't print because it's trying to catch a NameError\")\nexcept TypeError:\n    print(\"caught a TypeError\")\n\ncaught a TypeError\n\n\nIn this case, the inner handler is looking for a NameError, but we raised a TypeError. Since the inner handler can’t catch it, Python checks the outer handler, which successfully catches the TypeError.\nOur second example is different. Here, the inner handler does catch the TypeError, but then it raises a new NameError:\n\ntry:\n    try:\n        raise TypeError(\"oh no!\")\n    except TypeError:\n        print(\"we caught a TypeError\")\n\n        raise NameError(\"here is a name error\")\n\n        print(\"this will not print!\")\nexcept NameError:\n    print(\"caught a NameError\")\n\nwe caught a TypeError\ncaught a NameError\n\n\nThe inner handler catches the TypeError but then creates a new problem by raising a NameError. Fortunately, the outer handler catches this new error, preventing our program from crashing.\n\n\nUsing else and finally\nWhen working with try/except blocks, we can add two special clauses that give us more control over our code: else and finally.\nThe else clause lets us run code only if no errors occurred in the try block. As in, “try this code, and if it works without errors, do this extra step.”\nThe finally clause runs its code regardless of whether an error happened or not. It’s like saying “no matter what happens, always do this cleanup step.” This is a good choice for tasks that need to happen even if errors occur like closing files or database connections.\nThe else clause is useful for several reasons:\n\nIt keeps your error handling code separate from your normal processing code\nIt ensures certain operations only happen when everything works correctly\nIt prevents catching unrelated errors that might occur in your processing code\n\nWhile the else clause isn’t very common in Python code, it serves specific purposes. One important use is running additional code before any finalization steps without including it in the try block itself. Without using else, you’d have to put this code in the try block, which means unintended errors might get caught and handled incorrectly.\nUnlike finally (which always runs), the else clause only runs when the try block succeeds completely. This makes it useful for operations that should only happen when everything works as expected.\nHere’s a simple example showing how else can make your code cleaner:\n\ndef example(): ...\ndef handle_failure(error): ...\ndef handle_success(result): ...\n\ntry:\n    result = example()\n    # Make a boolean flag that says we were successful\n    success = True\nexcept MagicError as error:\n    handle_failure(error)\n\n# We only want to run this on success, so it must be behind a flag\nif success:\n    handle_success(result)\n\n\n# With else -- cleaner approach\ntry:\n    result = example()\nexcept MagicError as error:\n    handle_failure(error)\nelse:\n    handle_success(result)\n\nLet’s try an example that uses all of the clauses: try, except, else, and finally. This simple example shows how to handle different situations when searching a protein database. The different parts handle specific situations:\n\ndef find_protein(protein_database, entry):\n    try:\n        # Try to find the protein in the database.\n        info = protein_database[entry]\n    except KeyError:\n        # If it is not found, log an error.\n        print(f\"Entry '{entry}' not found in the database\")\n    else:\n        # If it is found, return the info\n        return info\n    finally:\n        # Regardless of success or failure, log a message saying you checked for the entry.\n        print(f\"Search completed for entry {entry}\")\n\n\n# Example usage\nprotein_database = {\n    \"P00452\": {\n        \"gene\": \"nrdA\",\n        \"protein\": \"Ribonucleoside-diphosphate reductase 1 subunit alpha\",\n    },\n    \"P00582\": {\"gene\": \"polA\", \"protein\": \"DNA polymerase I\"},\n}\n\nentries = [\"P00582\", \"P19822\", \"P00452\"]\nfor entry in entries:\n    # If the entry is found, return the info, if not, it will return None\n    info = find_protein(protein_database, entry)\n\n    # Since this might be none, we have to check that it exists before working\n    # with it.\n    if info:\n        print(info[\"gene\"], info[\"protein\"], sep=\" -&gt; \")\n\n    print()\n\nSearch completed for entry P00582\npolA -&gt; DNA polymerase I\n\nEntry 'P19822' not found in the database\nSearch completed for entry P19822\n\nSearch completed for entry P00452\nnrdA -&gt; Ribonucleoside-diphosphate reductase 1 subunit alpha\n\n\n\nHere is a flowchart to help you visualize how the logic flows through the try/except/else/finally code structure.\n\n\n\ntry/except/else/finally flowchart\n\n\n\n\nCombining Techniques\nLet’s take a look at an example that combines a few of the techniques we have talked about so far. Here we’re trying to read a file, convert each line to an integer, and store those integers in a list. Our code is structured with a try clause followed by several except clauses to handle different types of errors:\n\ndef read_integers(file_name):\n    \"\"\"Read a file and convert each line to an integer.\"\"\"\n    with open(file_name) as file:\n        return [int(line.strip()) for line in file]\n\n\ntry:\n    read_integers(\"the_best_numbers.txt\")\n# Dealing with files can cause errors in the OSError family\nexcept OSError as error:\n    print(f\"an error reading the file occurred: {error=}\")\n# Trying to a convert a string to an integer can fail too\nexcept ValueError as error:\n    print(f\"could not convert line to an integer: {error=}\")\n# This is a \"catch-all\" clause, since we want to log any unexpected errors\nexcept Exception as error:\n    print(f\"Unexpected error: {error=}\")\n    # Since it's not good practice to handle errors we are not expecting,\n    # we reraise the error and then the caller of this code can handle it\n    # how they want.\n    raise\n\nan error reading the file occurred: error=FileNotFoundError(2, 'No such file or directory')\n\n\nThe first except clause catches any OSError. These errors happen when something goes wrong with the file system, like if \"the_best_numbers.txt\" doesn’t exist. The OSError family includes specific errors like FileNotFoundError (when the file doesn’t exist), PermissionError (when you don’t have permission to read the file), and other file-related problems.\nThe second except clause catches ValueError. This happens if the int() function can’t convert a line to an integer. For instance, if a line contains “ABC” instead of a number like “123”, a ValueError will occur.\nThe last except clause catches any other type of Exception. This acts as a safety net for unexpected errors. When an unexpected error occurs, we:\n\nPrint information about the error\nRe-raise the error using the raise statement\n\nRe-raising an error means that after we handle it partially (in this case, by printing information), we pass the error up to whatever code called our function. This is useful when you want to log an error but still want the calling code to to have to deal with it because there is no way to recover at the location which the error happened (i.e., you might not have enough context to do anything about it right then and there).",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errors & Exceptions</span>"
    ]
  },
  {
    "objectID": "chapters/06_errors.html#creating-custom-exceptions",
    "href": "chapters/06_errors.html#creating-custom-exceptions",
    "title": "6  Errors & Exceptions",
    "section": "Creating Custom Exceptions",
    "text": "Creating Custom Exceptions\nPython packages and libraries often create their own custom error types. For example:\n\nBiopython defines a TreeError class to alert users when something goes wrong with phylogenetic trees.\nPandas defines a MergeError for problems that occur when trying to merge data frames.\n\nThese custom errors make it easier for users to handle problems specific to that library. Users can then distinguish between errors from the library and errors from their own code.\nLet’s look at an example. First, we’ll write code without a custom error, then improve it by adding one.\n\ndef parse_dna_string(dna_string):\n    \"\"\"Parse a DNA string, validating the nucleotides.\"\"\"\n    valid_bases = {\"A\", \"C\", \"G\", \"T\", \"N\"}\n\n    for i, base in enumerate(dna_string):\n        if base not in valid_bases:\n            raise ValueError(f\"Invalid DNA base at index {i}: '{base}'\")\n\n    return dna_string\n\n\nprint(parse_dna_string(\"ACTG\"))\n\ntry:\n    print(parse_dna_string(\"ACXG\"))\nexcept ValueError as error:\n    print(f\"{error=}\")\n\nACTG\nerror=ValueError(\"Invalid DNA base at index 2: 'X'\")\n\n\nThis works fine, but imagine you’re writing a library with many classes for different aspects of sequence analysis and file parsing. Error handling could become confusing. Creating custom errors helps users understand and handle problems more clearly.\nA common approach is to define a base error class for your package, and then create specific error types that inherit from it. For example, if our package is called EasyBio, we might do this:\n\nclass EasyBioError(Exception):\n    \"\"\"Base class for all EasyBio package errors.\"\"\"\n    pass\n\nclass InvalidBaseError(EasyBioError):\n    \"\"\"Error raised when a DNA sequence contains invalid characters\"\"\"\n    pass\n\n# We could define more specific errors for other situations too\n\ndef parse_dna_string(dna_string):\n    valid_bases = {\"A\", \"C\", \"G\", \"T\", \"N\"}\n\n    for i, base in enumerate(dna_string):\n        if base not in valid_bases:\n            raise InvalidBaseError(f\"Invalid DNA base at index {i}: '{base}'\")\n\n    return dna_string\n\n\nprint(parse_dna_string(\"ACTG\"))\n\ntry:\n    print(parse_dna_string(\"ACXG\"))\nexcept InvalidBaseError as error:\n    print(f\"{error=}\")\n\nACTG\nerror=InvalidBaseError(\"Invalid DNA base at index 2: 'X'\")\n\n\nThis code is more descriptive about what went wrong - specifically that we found an invalid nucleotide. The benefits of this approach become clearer in larger packages with many different types of potential errors.\nBenefits of using custom exceptions include:\n\nClear hierarchy: Users can catch just the base exception (EasyBioError) to handle any error from your library, or catch specific exceptions for targeted handling.\nImproved error messaging: Custom exceptions can include field-specific information that helps users understand what went wrong in their context.\nDocumentation: Custom exceptions serve as self-documenting code, showing users what can go wrong.\n\nUsers of your code will often expect to see custom error types that are specific to your package or library. This approach lets you control which errors users need to handle and gives them clear information about what went wrong.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errors & Exceptions</span>"
    ]
  },
  {
    "objectID": "chapters/06_errors.html#general-tips",
    "href": "chapters/06_errors.html#general-tips",
    "title": "6  Errors & Exceptions",
    "section": "General Tips",
    "text": "General Tips\nNow that we’ve explored errors and exceptions, let’s go through some general tips about how to deal with them.\n\nUse Descriptive Error Messages\nIt’s important to include helpful details when raising errors. This makes your code more robust and provides valuable context to anyone using your functions.\nBe specific and descriptive:\n# Too vague\nraise ValueError(\"Invalid input\")\n\n# More descriptive\nraise ValueError(\"Expected DNA sequence but found invalid characters\")\n\n# Shows the specific problems with the sequence\nraise ValueError(f\"Expected DNA sequence but found invalid characters at positions {invalid_positions}\")\nInclude relevant values:\nif start &gt;= end:\n    raise ValueError(f\"Start position ({start}) must be less than end position ({end})\")\nSuggest solutions when possible:\nif not os.path.exists(filepath):\n    raise FileNotFoundError(f\"File '{filepath}' not found. Check spelling or use absolute path.\")\n\n# Not as good:\nraise ConnectionError(\"connection failed\")\n\n# Better\nraise ConnectionError(\"Database connection failed: check that server is running on port 5432\")\nDocument the exceptions your functions can raise:\ndef parse_fasta(filename):\n    \"\"\"\n    Parse a FASTA file and return sequences.\n\n    Args:\n        filename: Path to the FASTA file\n\n    Returns:\n        List of (header, sequence) tuples\n\n    Raises:\n        FileNotFoundError: If the file doesn't exist\n        ValueError: If the file is not in valid FASTA format\n    \"\"\"\n    pass\nThese suggestions will make debugging easier for both you and anyone using your code.\n\n\nWhen to Catch Exceptions\nLet’s talk about you should catch exceptions and when it’s better to let them bubble up through your program.\nYou should catch exceptions when:\n\nYou can recover meaningfully\n\nYou can provide a default value if an error occurs (for example, when calculating fold change and dividing by zero, just return zero)\nYou can safely skip problematic data (for example, when processing multiple sequences from a FASTA file and one is corrupted, just skip that sequence)\n\nYou need to clean up resources (for example, close a database connection if a query fails)\nYou want to translate an error into a different, more appropriate error type\n\nYou should not catch exceptions when:\n\nThere is no reasonable way to recover from the error\n\nIf you have no recovery strategy, let the exception move up to a level that can handle it\nFor example:\n\nWhen a user provides a file name that doesn’t exist\nWhen a database connection fails\n\n\nThere is a cleaner alternative (for example, using dict.get to provide a default value instead of catching a KeyError)\n\n\n\n\nDecision Tree for Catching Exceptions\n\n\n\n\nOther tips\n\nWhen you decide to catch an exception, catch it as specifically as possible\n\nPrefer catching specific exceptions like ValueError or FileNotFoundError rather than broad ones like Exception\nThis prevents accidentally hiding bugs by catching exceptions you weren’t expecting\n\nDon’t silently ignore exceptions\n\nAt minimum, you should at least log a message to let users know something went wrong\n\n\n\n\nExample\nHere is a tiny example that breaks pretty much all the suggestions that we have given:\n\ndef example(x, y, z):\n    try:\n        return potentially_risky_function(x, y, z)\n    except Exception:\n        pass\n\nThis is better though!\ndef example(x, y, z):\n    try:\n        return potentially_risky_function(x, y, z)\n    except ValueError as e:\n        print(f\"WARNING -- Invalid value encountered: {e}\")\n        return default_value\n    except IOError as e:\n        print(f\"ERROR -- IO error: {e}\")\n        # Re-raise errors we can't handle\n        raise",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errors & Exceptions</span>"
    ]
  },
  {
    "objectID": "chapters/06_errors.html#summary",
    "href": "chapters/06_errors.html#summary",
    "title": "6  Errors & Exceptions",
    "section": "Summary",
    "text": "Summary\nIn this tutorial, we covered Python exceptions and how to handle them.\n\nSyntax errors happen when your code breaks Python’s grammar rules. These must be fixed before your code can run.\nExceptions occur during program execution when something unexpected happens, like trying to divide by zero.\ntry/except blocks let you catch exceptions and handle them smoothly, similar to how you might have contingency plans in an experiment.\nThe exception hierarchy allows you to catch specific error types (like FileNotFoundError) or broader categories of errors (like OSError).\nelse and finally clauses give you extra control in error handling, letting you run code when no errors occur or ensure cleanup happens regardless.\nCustom exceptions help you write more readable and maintainable code by creating error types specific to your program.\n\nError handling is a crucial skill for building robust programs that can recover gracefully when things go wrong. Practice identifying where your code might fail (like when reading files or processing data) and implement appropriate exception handling to build more reliable applications for your research.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errors & Exceptions</span>"
    ]
  },
  {
    "objectID": "chapters/06_errors.html#suggested-readings",
    "href": "chapters/06_errors.html#suggested-readings",
    "title": "6  Errors & Exceptions",
    "section": "Suggested Readings",
    "text": "Suggested Readings\nYou might enjoy checking out some of these resources:\n\nPython docs tutorial about errors and exceptions\nReal Python’s introduction to exceptions\nReal Python’s discussion of built-in exceptions\nStackOverflow post about the else block\nStackOverflow post about raising exceptions",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Errors & Exceptions</span>"
    ]
  }
]